source,target
"@Deprecated
public static final String[] METHODHANDLE_NAMES = { """", ""getField"", ""getStatic"", ""putField"", ""putStatic"", ""invokeVirtual"", ""invokeStatic"", ""invokeSpecial"", ""newInvokeSpecial"", ""invokeInterface"" };",0
"return opens_table;
",0
"// TODO: mutable public array!!
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"", ""LocalVariableTypeTable"", ""EnclosingMethod"", ""StackMapTable"", ""BootstrapMethods"", ""MethodParameters"" };",1
"@Deprecated
public static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",1
"this.bootstrap_methods = bootstrap_methods;
",0
"this.annotation_table = annotation_table;
",0
"@Deprecated
public static final String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0
"this.arg_types = arg_types;
",0
"public static final int[] PRODUCE_STACK = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 4, 4, 5, 6, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 0, 2, 1, 2, 1, 1, 2, 1, 2, 2, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, UNPREDICTABLE, 0, UNPREDICTABLE, 0, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, UNPREDICTABLE, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNPREDICTABLE, UNPREDICTABLE };",1
"this.local_variable_table = local_variable_table;
",0
"return line_number_table;
",0
"return evalues;
",0
"return inner_classes;
",0
"public static final String[] TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""boolean"", ""char"", ""float"", ""double"", ""byte"", ""short"", ""int"", ""long"", ""void"", ""array"", ""object"", ""unknown"", ""address"" };",1
"return requires_table;
",0
"public static final String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",1
"public static final String[] CONSTANT_NAMES = { """", ""CONSTANT_Utf8"", """", ""CONSTANT_Integer"", ""CONSTANT_Float"", ""CONSTANT_Long"", ""CONSTANT_Double"", ""CONSTANT_Class"", ""CONSTANT_String"", ""CONSTANT_Fieldref"", ""CONSTANT_Methodref"", ""CONSTANT_InterfaceMethodref"", ""CONSTANT_NameAndType"", """", """", ""CONSTANT_MethodHandle"", ""CONSTANT_MethodType"", """", ""CONSTANT_InvokeDynamic"" };",1
"this.annotation_table = annotation_table;
",0
"this.evalues = datums;
",0
"return bootstrap_arguments;
",0
"return code;
",0
"return attributes;
",0
"i = ((ConstantClass) c).getNameIndex();
",0
"i = ((ConstantString) c).getStringIndex();
",0
"this.constant_pool = constant_pool;
",0
"str = ((ConstantUtf8) c).getBytes();
",0
"this.bytes = bytes;
",0
"return exception_index_table;
",0
"return annotations;
",0
"return local_variable_table;
",0
"this.map = map;
",0
"return bytes;
",0
"return bytes;
",0
"buf.append(""\t"");
case Const.INSTANCEOF:
index = bytes.readUnsignedShort();
",0
"return null;
",0
"return null;
",0
"if (bh_list == null) {
return new BranchHandle(i);
}
BranchHandle bh = bh_list;
bh_list = (BranchHandle) bh.getNext();
",0
"ConstantCP m = (ConstantCP) c;
",0
"return addLong(((ConstantLong) c).getBytes());
",0
"return addDouble(((ConstantDouble) c).getBytes());
",0
"return new EnumElementValueGen((EnumElementValue) value, cpool,
",0
"return new Float(value);
",0
"return new CHECKCAST(cp.addClass((ObjectType) t));
",0
"return new INSTANCEOF(cp.addClass((ObjectType) t));
",0
"int i = (l + r) / 2;
",0
"this.arg_types = arg_types;
",0
"return match;
",0
"return targets;
",0
"_out = new PrintWriter(out);
",0
"class_name = java_class.getClassName(); 
",0
"System.gc(); 
",0
"objreftype.subclassOf(curr) ) ){
",0
"String[] OPCODE_NAMES = { ""nop"", ""aconst_null"", ""iconst_m1"", ""iconst_0"", ""iconst_1"", ""iconst_2"", ""iconst_3"", ""iconst_4"", ""iconst_5"", ""lconst_0"", ""lconst_1"", ""fconst_0"", ""fconst_1"", ""fconst_2"", ""dconst_0"", ""dconst_1"", ""bipush"", ""sipush"", ""ldc"", ""ldc_w"", ""ldc2_w"", ""iload"", ""lload"", ""fload"", ""dload"", ""aload"", ""iload_0"", ""iload_1"", ""iload_2"", ""iload_3"", ""lload_0"", ""lload_1"", ""lload_2"", ""lload_3"", ""fload_0"", ""fload_1"", ""fload_2"", ""fload_3"", ""dload_0"", ""dload_1"", ""dload_2"", ""dload_3"", ""aload_0"", ""aload_1"", ""aload_2"", ""aload_3"", ""iaload"", ""laload"", ""faload"", ""daload"", ""aaload"", ""baload"", ""caload"", ""saload"", ""istore"", ""lstore"", ""fstore"", ""dstore"", ""astore"", ""istore_0"", ""istore_1"", ""istore_2"", ""istore_3"", ""lstore_0"", ""lstore_1"", ""lstore_2"", ""lstore_3"", ""fstore_0"", ""fstore_1"", ""fstore_2"", ""fstore_3"", ""dstore_0"", ""dstore_1"", ""dstore_2"", ""dstore_3"", ""astore_0"", ""astore_1"", ""astore_2"", ""astore_3"", ""iastore"", ""lastore"", ""fastore"", ""dastore"", ""aastore"", ""bastore"", ""castore"", ""sastore"", ""pop"", ""pop2"", ""dup"", ""dup_x1"", ""dup_x2"", ""dup2"", ""dup2_x1"", ""dup2_x2"", ""swap"", ""iadd"", ""ladd"", ""fadd"", ""dadd"", ""isub"", ""lsub"", ""fsub"", ""dsub"", ""imul"", ""lmul"", ""fmul"", ""dmul"", ""idiv"", ""ldiv"", ""fdiv"", ""ddiv"", ""irem"", ""lrem"", ""frem"", ""drem"", ""ineg"", ""lneg"", ""fneg"", ""dneg"", ""ishl"", ""lshl"", ""ishr"", ""lshr"", ""iushr"", ""lushr"", ""iand"", ""land"", ""ior"", ""lor"", ""ixor"", ""lxor"", ""iinc"", ""i2l"", ""i2f"", ""i2d"", ""l2i"", ""l2f"", ""l2d"", ""f2i"", ""f2l"", ""f2d"", ""d2i"", ""d2l"", ""d2f"", ""i2b"", ""i2c"", ""i2s"", ""lcmp"", ""fcmpl"", ""fcmpg"", ""dcmpl"", ""dcmpg"", ""ifeq"", ""ifne"", ""iflt"", ""ifge"", ""ifgt"", ""ifle"", ""if_icmpeq"", ""if_icmpne"", ""if_icmplt"", ""if_icmpge"", ""if_icmpgt"", ""if_icmple"", ""if_acmpeq"", ""if_acmpne"", ""goto"", ""jsr"", ""ret"", ""tableswitch"", ""lookupswitch"", ""ireturn"", ""lreturn"", ""freturn"", ""dreturn"", ""areturn"", ""return"", ""getstatic"", ""putstatic"", ""getfield"", ""putfield"", ""invokevirtual"", ""invokespecial"", ""invokestatic"", ""invokeinterface"", ""invokedynamic"", ""new"", ""newarray"", ""anewarray"", ""arraylength"", ""athrow"", ""checkcast"", ""instanceof"", ""monitorenter"", ""monitorexit"", ""wide"", ""multianewarray"", ""ifnull"", ""ifnonnull"", ""goto_w"", ""jsr_w"", ""breakpoint"", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ""impdep1"", ""impdep2"" };",0
"String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
"String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = { ""java.lang.Cloneable"", ""java.io.Serializable"" };",0
"String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
"String[] ACCESS_NAMES = { ""public"", ""private"", ""protected"", ""static"", ""final"", ""synchronized"", ""volatile"", ""transient"", ""native"", ""interface"", ""abstract"", ""strictfp"", ""synthetic"", ""annotation"", ""enum"" };",0
"@Deprecated
Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = { NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR, EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR };",0
"@Deprecated
Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0
"this.annotationTable = annotationTable;
",0
"this.bootstrapMethods = bootstrapMethods;
",0
"this.constantPool = constantPool;
",0
"str = constantToString(((ConstantNameAndType) c).getNameIndex(),
",0
"created++;
",0
"this.bytes = bytes;
",0
"return innerClasses;
",0
"return attributes;
",0
"return exportsTable;
",0
"return classes;
",0
"return parameterAnnotationTable;
",0
"return new String(buf);
",0
"return map;
",0
"this.map = map;
",0
"return bytes;
",0
"final ConstantNameAndType n = (ConstantNameAndType) c;
",0
"return new EnumElementValueGen((EnumElementValue) value, cpool,
",0
"return new ClassElementValueGen((ClassElementValue) value, cpool,
",0
"return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));
",0
"switch (i.getOpcode()) {
case Const.JSR:
case Const.GOTO:
max_additional_bytes += 2;
break;
case Const.TABLESWITCH:
case Const.LOOKUPSWITCH:
max_additional_bytes += 3;
",0
"return indices;
",0
"this.ignored_packages = ignored_packages;
",0
"wide = false; 
",0
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
",0
"index = bytes.readShort();
buf.append(constantHtml.referenceConstant(index));
break;
",0
"new GraphicalVerifier();
",0
"objreftype.subclassOf(curr) ) ) {
",0
"final LocalVariables lvs = new LocalVariables(locals.length);
for (int i=0; i<locals.length; i++) {
lvs.locals[i] = this.locals[i];
}
return lvs;
",0
"final OperandStack newstack = new OperandStack(this.maxStack);
@SuppressWarnings(""unchecked"") 
final ArrayList<Type> clone = (ArrayList<Type>) this.stack.clone();
newstack.stack = clone;
return newstack;
",0
"public static final String[] CLASS_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""java.lang.Boolean"", ""java.lang.Character"", ""java.lang.Float"", ""java.lang.Double"", ""java.lang.Byte"", ""java.lang.Short"", ""java.lang.Integer"", ""java.lang.Long"", ""java.lang.Void"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
"public static final String[] SHORT_TYPE_NAMES = { ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ""Z"", ""C"", ""F"", ""D"", ""B"", ""S"", ""I"", ""J"", ""V"", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE };",0
"// TODO: mutable public array!!
public static final String[] ATTRIBUTE_NAMES = { ""SourceFile"", ""ConstantValue"", ""Code"", ""Exceptions"", ""LineNumberTable"", ""LocalVariableTable"", ""InnerClasses"", ""Synthetic"", ""Deprecated"", ""PMGClass"", ""Signature"", ""StackMap"", ""RuntimeVisibleAnnotations"", ""RuntimeInvisibleAnnotations"", ""RuntimeVisibleParameterAnnotations"", ""RuntimeInvisibleParameterAnnotations"", ""AnnotationDefault"" };",0
"@Deprecated
public static final Class<?>[] EXCS_ARRAY_EXCEPTION = { NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION };",0
"@Deprecated
public static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = { NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR };",0
"@Deprecated
public static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = { NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR, EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR };",0
"return annotation_table;
",0
"return bootstrap_arguments;
",0
"this.bootstrap_methods = bootstrap_methods;
",0
"return bootstrap_methods;
",0
"this.bootstrap_methods = bootstrap_methods;
",0
"return code;
",0
"ConstantMethodType cmt = (ConstantMethodType) c;
",0
"i = ((ConstantString) c).getStringIndex();
",0
"str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)
",0
"created++;
",0
"if (debug) {
System.out.println(str);
}
}
",0
"this.line_number_table = line_number_table;
",0
"return line_number_table;
",0
"this.local_variable_type_table = local_variable_table;
",0
"return parameterAnnotationEntries;
",0
"return annotation_table;
",0
"return types_of_locals;
",0
"return bytes;
",0
"this.bytes = bytes;
",0
"System.exit(-1);
",0
"ConstantClass s = (ConstantClass) c;
",0
"return addInteger(((ConstantInteger) c).getBytes());
",0
"ConstantString s = (ConstantString) c;
",0
"return new Double(value);
",0
"return new ArrayElementValueGen((ArrayElementValue) value, cpool,
",0
"return new SimpleElementValueGen((SimpleElementValue) value, cpool,
",0
"return new Float(value);
",0
public static final Instruction[] INSTRUCTIONS = new Instruction[256];,0
"return byte_positions;
",0
"return match;
",0
"return targets;
",0
"BranchHandle bh = (BranchHandle) branch_map.get(bi);
",0
"type = ((NEWARRAY) i).getType();
",0
"index = bytes.readShort();
buf.append(constant_html.referenceConstant(index));
break;
",0
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_code.html""));
",0
"file = new PrintWriter(new FileOutputStream(dir + class_name + ""_cp.html""));
",0
"contentPane = (JPanel) this.getContentPane();
",0
"if ((obj.getAccessFlags() & ~(Const.ACC_PUBLIC|Const.ACC_PRIVATE|Const.ACC_PROTECTED|Const.ACC_STATIC|
",0
"public StringEncoderComparator() {
this.stringEncoder = null; 
}
public StringEncoderComparator(StringEncoder stringEncoder) {
this.stringEncoder = stringEncoder;
}
@Override
public int compare(Object o1, Object o2) {
int compareCode = 0;
try {
Comparable s1 = (Comparable) this.stringEncoder.encode(o1);
Comparable s2 = (Comparable) this.stringEncoder.encode(o2);
compareCode = s1.compareTo(s2);
} catch (EncoderException ee) {
compareCode = 0;
}
return compareCode;
",0
"if (m == null || !m.find()) {
",0
"return null;
",0
"return null;
",0
"modulus = (++modulus) % 3;
",0
"return decodeHex(new String(array).toCharArray());
",0
"return md5(data.getBytes());
",0
"return null;
",0
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 3) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea << 2) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 2 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 11) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  6) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  1) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  4) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 3 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 19) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 14) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  9) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  4) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  1) & MASK_5BITS]; 
buffer[pos++] = PAD;
buffer[pos++] = PAD;
buffer[pos++] = PAD;
break;
case 4 : 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 27) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 22) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 17) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >> 12) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  7) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea >>  2) & MASK_5BITS]; 
buffer[pos++] = encodeTable[(int)(bitWorkArea <<  3) & MASK_5BITS]; 
buffer[pos++] = PAD;
",0
"switch (modulus) {
case 2 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 3 : 
bitWorkArea = bitWorkArea >> 2; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return new String(encodeHex(array)).getBytes();
",0
"return md5(data.getBytes());
",0
"switch(symb) {
case 'A' : case 'E' : case 'I' : case 'O' : case 'U' :
if (n == 0) {
code.append(symb);
}
break ; 
case 'B' :
if ( isPreviousChar(local, n, 'M') &&
isLastChar(wdsz, n) ) { 
break;
}
code.append(symb);
break;
case 'C' : 
if ( isPreviousChar(local, n, 'S') &&
!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) ) {
break;
}
if (regionMatch(local, n, ""CIA"")) { 
code.append('X');
break;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0)) {
code.append('S');
break; 
}
if (isPreviousChar(local, n, 'S') &&
isNextChar(local, n, 'H') ) { 
code.append('K') ;
break ;
}
if (isNextChar(local, n, 'H')) { 
if ((n == 0) &&
(wdsz >= 3) &&
isVowel(local,2) ) { 
code.append('K');
} else {
code.append('X'); 
}
} else {
code.append('K');
}
break ;
case 'D' :
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'G') &&
(FRONTV.indexOf(local.charAt(n + 2)) >= 0)) { 
code.append('J'); n += 2 ;
} else {
code.append('T');
}
break ;
case 'G' : 
if (isLastChar(wdsz, n + 1) &&
isNextChar(local, n, 'H')) {
break;
}
if (!isLastChar(wdsz, n + 1) &&
isNextChar(local,n,'H') &&
!isVowel(local,n+2)) {
break;
}
if ((n > 0) &&
( regionMatch(local, n, ""GN"") ||
regionMatch(local, n, ""GNED"") ) ) {
break; 
}
if (isPreviousChar(local, n, 'G')) {
hard = true ;
} else {
hard = false ;
}
if (!isLastChar(wdsz, n) &&
(FRONTV.indexOf(local.charAt(n + 1)) >= 0) &&
(!hard)) {
code.append('J');
} else {
code.append('K');
}
break ;
case 'H':
if (isLastChar(wdsz, n)) {
break ; 
}
if ((n > 0) &&
(VARSON.indexOf(local.charAt(n - 1)) >= 0)) {
break;
}
if (isVowel(local,n+1)) {
code.append('H'); 
}
break;
case 'F':
case 'J' :
case 'L' :
case 'M':
case 'N' :
case 'R' :
code.append(symb);
break;
case 'K' :
if (n > 0) { 
if (!isPreviousChar(local, n, 'C')) {
code.append(symb);
}
} else {
code.append(symb); 
}
break ;
case 'P' :
if (isNextChar(local,n,'H')) {
code.append('F');
} else {
code.append(symb);
}
break ;
case 'Q' :
code.append('K');
break;
case 'S' :
if (regionMatch(local,n,""SH"") ||
regionMatch(local,n,""SIO"") ||
regionMatch(local,n,""SIA"")) {
code.append('X');
} else {
code.append('S');
}
break;
case 'T' :
if (regionMatch(local,n,""TIA"") ||
regionMatch(local,n,""TIO"")) {
code.append('X');
break;
}
if (regionMatch(local,n,""TCH"")) {
break;
}
if (regionMatch(local,n,""TH"")) {
code.append('0');
} else {
code.append('T');
}
break ;
case 'V' :
code.append('F'); break ;
case 'W' : case 'Y' : 
if (!isLastChar(wdsz,n) &&
isVowel(local,n+1)) {
code.append(symb);
}
break ;
case 'X' :
code.append('K'); code.append('S');
break ;
case 'Z' :
code.append('S'); break ;
",0
"return null;
",0
"return null;
",0
protected static byte ESCAPE_CHAR = '%';,0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",0
"return null;
",0
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0
"return null;
",0
"return null;
",0
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0
"return null;
",0
"return null;
",0
"return null;
",0
"if (m == null || !m.find()) {
",0
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0
"return null;
",0
"if (m == null || !m.find()) {
",0
"return null;
",0
"h ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
h ^= ((long) data[index + 5] & 0xff) << 40;
",0
"k1 ^= unprocessed[2] << 16;
case 2:
k1 ^= unprocessed[1] << 8;
",0
"k1 ^= (data[index + 2] & 0xff) << 16;
case 2:
k1 ^= (data[index + 1] & 0xff) << 8;
",0
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0
"switch (modulus) {
case 1 :
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 :
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0
"return null;
",0
"return null;
",0
"return null;
",0
protected final byte PAD = PAD_DEFAULT;,0
"return null;
",0
"return null;
",0
"switch (offset + length - index) {
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= ((long) data[index] & 0xff);
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
hash ^= k1;
",0
"k1 ^= data[index + 2] << 16;
case 2:
k1 ^= data[index + 1] << 8;
",0
"switch (offset + length - index) {
case 15:
k2 ^= ((long) data[index + 14] & 0xff) << 48;
case 14:
k2 ^= ((long) data[index + 13] & 0xff) << 40;
case 13:
k2 ^= ((long) data[index + 12] & 0xff) << 32;
case 12:
k2 ^= ((long) data[index + 11] & 0xff) << 24;
case 11:
k2 ^= ((long) data[index + 10] & 0xff) << 16;
case 10:
k2 ^= ((long) data[index + 9] & 0xff) << 8;
case 9:
k2 ^= data[index + 8] & 0xff;
k2 *= C2;
k2 = Long.rotateLeft(k2, R3);
k2 *= C1;
h2 ^= k2;
case 8:
k1 ^= ((long) data[index + 7] & 0xff) << 56;
case 7:
k1 ^= ((long) data[index + 6] & 0xff) << 48;
case 6:
k1 ^= ((long) data[index + 5] & 0xff) << 40;
case 5:
k1 ^= ((long) data[index + 4] & 0xff) << 32;
case 4:
k1 ^= ((long) data[index + 3] & 0xff) << 24;
case 3:
k1 ^= ((long) data[index + 2] & 0xff) << 16;
case 2:
k1 ^= ((long) data[index + 1] & 0xff) << 8;
case 1:
k1 ^= data[index] & 0xff;
k1 *= C1;
k1 = Long.rotateLeft(k1, R1);
k1 *= C2;
h1 ^= k1;
",0
"switch (unprocessedLength) {
case 3:
k1 ^= (unprocessed[2] & 0xff) << 16;
case 2:
k1 ^= (unprocessed[1] & 0xff) << 8;
case 1:
k1 ^= (unprocessed[0] & 0xff);
k1 *= C1_32;
k1 = Integer.rotateLeft(k1, R1_32);
k1 *= C2_32;
result ^= k1;
",0
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0
"switch (modulus) { 
case 1 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 2) & MASK_6BITS]; 
buffer[pos++] = encodeTable[(bitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 : 
buffer[pos++] = encodeTable[(bitWorkArea >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(bitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0
"return null;
",0
"return null;
",0
"return null;
",0
protected final String charset;,0
"switch (modulus) {
case 1 :
buffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
buffer[pos++] = PAD;
}
break;
case 2 :
buffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];
buffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];
buffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
buffer[pos++] = PAD;
",0
"modulus = (++modulus) % 3;
",0
"return decodeHex(new String(array).toCharArray());
",0
"byte[] byteArray = object instanceof String ? ((String) object).getBytes() : (byte[]) object;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"switch (modulus) {
case 2 : 
x = x >> 4;
buffer[pos++] = (byte) ((x) & MASK_8BITS);
break;
case 3 : 
x = x >> 2;
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((x) & MASK_8BITS);
",0
"return null;
",0
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,0
"return null;
",0
"switch (modulus) {
case 2 : 
buffer[pos++] = (byte) ((bitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
buffer[pos++] = (byte) ((bitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
bitWorkArea = bitWorkArea >> 4; 
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 5 : 
bitWorkArea = bitWorkArea >> 1;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 6 : 
bitWorkArea = bitWorkArea >> 6;
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
break;
case 7 : 
bitWorkArea = bitWorkArea >> 3;
buffer[pos++] = (byte) ((bitWorkArea >> 24) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea >> 8) & MASK_8BITS);
buffer[pos++] = (byte) ((bitWorkArea) & MASK_8BITS);
",0
"return null;
",0
"return null;
",0
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
"dst[off + i] = (byte) (value >>> i * Byte.SIZE);
",0
"switch (length - index) {
case 3:
h ^= (data[index + 2] & 0xff) << 16;
case 2:
h ^= (data[index + 1] & 0xff) << 8;
case 1:
h ^= (data[index] & 0xff);
h *= M32;
",0
"case 7: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
case 6: localCrc = (localCrc >>> 8) ^ T[((localCrc ^ b[i++]) << 24) >>> 24];
",0
"switch(len) {
case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0
"final SomeLanguages someLanguages = (SomeLanguages) other;
",0
"return null;
",0
"if (m == null || !m.find()) {
",0
"return null;
",0
"return null;
",0
"return null;
",0
"String replacedName = name.toUpperCase();
",0
"return null;
",0
"return null;
",0
"return null;
",0
"if (m == null || !m.find()) {
",0
"if (m == null || !m.find()) {
",0
"} else if (sumLength >= FIVE && sumLength <= SEVEN) {
",0
"final SomeLanguages sl = (SomeLanguages) other;
",0
"switch(len) {
case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 5: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 4: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 3: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 2: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 1: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0
"case 7: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
case 6: localCrc = (localCrc >>> 8) ^ T[T8_0_start + ((localCrc ^ b[off++]) & 0xff)];
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"schedule[j++] = s & 0xffffffff;
",1
"final int txtLength = txt.length();
",1
"return null;
",0
"this.soundexMapping= mapping;
",1
"switch (context.modulus) {
case 2 : 
context.ibitWorkArea = context.ibitWorkArea >> 4; 
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
break;
case 3 : 
context.ibitWorkArea = context.ibitWorkArea >> 2; 
buffer[context.pos++] = (byte) ((context.ibitWorkArea >> 8) & MASK_8BITS);
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);
",1
"} else if (sumLength >= EIGHT && sumLength <= ELEVEN) {
",1
"switch (context.modulus) { 
case 1 : 
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 2) & MASK_6BITS]; 
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 4) & MASK_6BITS]; 
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
context.buffer[context.pos++] = PAD;
}
break;
case 2 : 
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 10) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea >> 4) & MASK_6BITS];
context.buffer[context.pos++] = encodeTable[(context.ibitWorkArea << 2) & MASK_6BITS];
if (encodeTable == STANDARD_ENCODE_TABLE) {
context.buffer[context.pos++] = PAD;
",0
"public static final char[] US_ENGLISH_MAPPING = ""01360240043788015936020505"".toCharArray();",1
"return sha512(data.getBytes());
",1
protected static byte ESCAPE_CHAR = '%';,0
"public static LanguageSet NO_LANGUAGES = new LanguageSet() {
@Override
public LanguageSet restrictTo(LanguageSet other) {
return this;
}
@Override
public boolean contains(String language) {
return false;
}
@Override
public boolean isSingleton() {
return false;
}
@Override
public String getAny() {
throw new NoSuchElementException(""Can't fetch any language from the empty language set."");
}
@Override
public boolean isEmpty() {
return true;
}
};",1
public static final char[] US_ENGLISH_MAPPING = US_ENGLISH_MAPPING_STRING.toCharArray();,1
protected static byte ESCAPE_CHAR = '%';,1
"switch (context.modulus) {
case 2 : 
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 2) & MASK_8BITS);
break;
case 3 : 
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 7) & MASK_8BITS);
break;
case 4 : 
context.lbitWorkArea = context.lbitWorkArea >> 4; 
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 5 : 
context.lbitWorkArea = context.lbitWorkArea >> 1;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 6 : 
context.lbitWorkArea = context.lbitWorkArea >> 6;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
break;
case 7 : 
context.lbitWorkArea = context.lbitWorkArea >> 3;
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 24) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 16) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea >> 8) & MASK_8BITS);
context.buffer[context.pos++] = (byte) ((context.lbitWorkArea) & MASK_8BITS);
",0
"@Deprecated
protected final byte PAD = PAD_DEFAULT;",0
"long len = ((pArray.length + unencodedBlockSize-1)  / unencodedBlockSize) * encodedBlockSize;
",1
private final Predicate<? super T> iPredicate1;,0
private final Factory<? extends O> iFactory;,0
private final Predicate<? super T> iPredicate2;,0
private final Predicate<? super T> iPredicate;,0
private final Factory<? extends E> factory;,0
"return (List<E>) decorated();
",0
"return (LinkEntry<K, V>) super.getEntry(key);
",0
"return hash;
",0
"final ArrayList<V> list = (ArrayList<V>) coll;
",0
"return (Set<E>) super.decorated();
",0
"return (SortedSet<E>) decorated();
",0
"protected final Transformer<? super E, ? extends E> transformer;",0
private final Comparator<? super E> comparator;,0
private final Closure<? super E>[] iClosures;,0
private final Factory<? extends O> iFactory;,0
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
private final Predicate<? super T> iPredicate;,0
private final Predicate<? super E>[] iPredicates;,0
private final Predicate<? super T> iPredicate;,0
"private final Transformer<? super E, ?> iTransformer;",0
private final Factory<? extends E> factory;,0
"final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;
",0
"return hash;
",0
"return hash;
",0
"V currentValue, nextValue;",0
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0
"return (Set<E>) super.decorated();
",0
"out.writeObject(comparator());
",0
"private UnmodifiableBidiMap<V, K> inverse;",0
"private final Transformer<C, K> keyTransformer;",0
"private final Transformer<? super E, ?> iTransformer;",0
"return (List<E>) decorated();
",0
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0
"return hash;
",0
"return (Set<E>) super.decorated();
",0
"return (Set<E>) super.decorated();
",0
"SynchronizedBagSet(final Set<E> set, final Object lock) {
super(set, lock);
}
",0
"protected final Transformer<? super E, ? extends E> transformer;",0
"private final Transformer<? super I, ? extends O> transformer;",0
"return null;
",0
private final Closure<? super E> iFalseClosure;,0
private final Predicate<? super T> iPredicate;,0
"this.array = array;
",0
"this.keys = keys;
",0
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0
"V currentValue, nextValue;",0
"delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
",0
"moveToMRU((LinkEntry<K, V>) entry);  
",0
"protected Node<K, V> next;",0
protected final AbstractMapMultiSet<E> parent;,0
"return (Set<E>) super.decorated();
",0
"private final Transformer<? super I, ? extends O> transformer;",0
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0
"entry = entry.next();
",0
"delegateMap.put(key3, value3);
case 2:
delegateMap.put(key2, value2);
",0
"moveToMRU((LinkEntry<K, V>) entry);  
",0
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0
"List<V> list = (List<V>) getMapping();
",0
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0
"this.collectionFactory = new InstantiateFactory<C>(collectionClazz, new Class[] { Integer.TYPE },
",0
"private final Transformer<? super K, ? extends K> keyTransformer;",0
private final Comparator<O> decorated;,0
private final Predicate<? super T> iPredicate1;,0
"return null;
",0
private final Predicate<? super T> iPredicate;,0
private final Predicate<? super T> iPredicate;,0
private final Closure<? super E> iDefault;,0
private final Predicate<? super T> iPredicate;,0
"return (List<E>) super.decorated();
",0
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0
"return hash;
",0
"buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0
"private final Transformer<? super K, ? extends K> keyTransformer;",0
"return (Set<E>) super.decorated();
",0
"out.writeObject(comparator());
",0
"final V value = last.getValue();
",0
"return TreeBidiMap.this.doEquals(obj, DataElement.VALUE);
",0
"protected final Transformer<? super E, ? extends E> transformer;",0
private final Predicate<? super T> iPredicate;,0
"private final Transformer<? super T, ? extends T> iTransformer;",0
"private final Transformer<? super T, Boolean> iTransformer;",0
"this.array = array;
",0
private final Factory<? extends E> factory;,0
"return (List<E>) decorated();
",0
protected K key;,0
"final ArrayList<V> list = (ArrayList<V>) coll;
",0
"return (UnmodifiableMultiValuedMap<K, V>) map;
",0
protected final AbstractMapMultiSet<E> parent;,0
"return (SortedSet<E>) decorated();
",0
"return this.doEquals(obj, KEY);
",0
"private final Transformer<? super T, ? extends T>[] iTransformers;",0
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
private transient Method iCloneMethod;,0
"private final Transformer<? super T, ? extends T> iTransformer;",0
"this.keys = keys;
",0
"return (List<E>) super.decorated();
",0
"return (List<E>) decorated();
",0
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0
"entry = entry.next();
",0
"return (Set<E>) super.decorated();
",0
"return (SortedSet<E>) decorated();
",0
"private final Transformer<C, K> keyTransformer;",0
"return null;
",0
"private final Transformer<? super I, ? extends O> iFalseTransformer;",0
"if (((ReferenceEntry<K, V>) entry).purge(ref)) {
",0
"return hash;
",0
"final List<V> list = (List<V>) getMapping();
",0
"final List<V> list = (List<V>) getMapping();
",0
"final Set<V> set = (Set<V>) getMapping();
",0
"Set<V> valueSet = (Set<V>) entry.getValue();
",0
"return (SortedSet<E>) decorated();
",0
"private final Transformer<? super T, ? extends T>[] iTransformers;",0
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0
"return hash;
",0
"return hash;
",0
"buf.append(',');
case 2:
buf.append(key2 == this ? ""(this Map)"" : key2);
",0
"protected Node<K, V> next;",0
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0
"final List<V> list = (List<V>) getMapping();
",0
"final List<V> list = ListUtils.emptyIfNull((List<V>) getMapping());
",0
"return null;
",0
"private final Transformer<? super T, ? extends T> iTransformer;",0
"private final Transformer<? super E, ?> iTransformer;",0
"final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;
",0
"entry = entry.next();
",0
"total += hash3 ^ (value3 == null ? 0 : value3.hashCode());
case 2:
total += hash2 ^ (value2 == null ? 0 : value2.hashCode());
",0
"catch (Exception e)
",0
".get(positionToIndex(getPosition())));
",1
"value = array.length == 0 ? null : new Byte(array[0]);
",1
"value = array.length == 0 ? null : new Integer(array[0]);
",1
"file = new File(fileName);
",0
"pstmt = conn.prepareStatement(query.toString());
",1
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0
"return new Float(n.floatValue());
",1
"catch (Exception ex)
",1
private final ConversionHandler dataConversionHandler;,1
"if (fileName.startsWith(""."" + File.separator))
",0
"pstmt = conn.prepareStatement(query.toString());
",1
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",1
"file = new File(fileName);
",0
"Token token = null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
return unescapeQuotes(removeQuotes(token.image));
case STRING:
token = jj_consume_token(STRING);
return token.image;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0
"catch (final Exception e)
",0
"if (fileName.startsWith(""."" + File.separator))
",0
"catch (final Exception e)
",0
"if (fileName.startsWith(""."" + File.separator))
",0
"return configurations;
",1
"hc = new BaseHierarchicalConfiguration((HierarchicalConfiguration) conf);
",1
"file = new File(fileName);
",0
"pstmt = conn.prepareStatement(query.toString());
",1
"return count % 2 == 1;
",1
"catch (Exception e)
",0
"catch (final Exception ex)
",0
private ExpressionEngine conversionExpressionEngine;,0
private List<ConfigData> configurations = new ArrayList<ConfigData>();,0
"value = array.length == 0 ? null : new Double(array[0]);
",1
"if (configs != null)
",0
"file = new File(fileName);
",0
"if ((jjbitVec0[i2] & l2) == 0L)
break;
if (kind > 19)
kind = 19;
jjCheckNAdd(3);
break;
",0
"synchronized (listeners)
",0
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
private AutoSaveListener autoSaveListener;,0
private ReloadingController reloadingController;,0
"return new Double(n.doubleValue());
",0
"{
@Override
public String lookup(String key)
{
Object value = ip.resolve(key);
return (value != null) ? value.toString() : null;
",0
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0
"return (src != null) ? src.clone() : null;
",0
"return getByte(key, new Byte(defaultValue)).byteValue();
",0
"writer = new OutputStreamWriter(out);
",0
protected Configuration configuration;,0
"pstmt = conn.prepareStatement(query.toString());
",0
"synchronized (configs)
",0
"synchronized (counterLock)
",0
"return new Short(n.shortValue());
",0
"return new Byte(n.byteValue());
",0
"catch (Exception ex)
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
private EntityResolver entityResolver = new DefaultEntityResolver();,0
"catch (Exception e)
",0
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0
"if (name == null)
",0
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0
private ConfigurationNode node;,0
"} catch (final Exception ex) {
",0
"pstmt = getConnection().prepareStatement(statement);
",0
"} catch (final Exception ex) {
",0
"return getShort(key, new Short(defaultValue)).shortValue();
",0
"PrintStream stream = new PrintStream(os);
",0
"ResultSet rs = pstmt.executeQuery();
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"ResultSet rs = pstmt.executeQuery();
",0
private final Object reloadLock;,0
private final Object reloadLock;,0
"instanceId = ++counter;
",0
"catch (Exception ex)
",0
"if (init)
",0
"return new Byte(n.byteValue());
",0
"return new Integer(n.intValue());
",0
"XMLNode nd = (XMLNode) createNode(node.getName());
",0
"{
super(name);
setReference(elem);
}
@Override
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
@Override
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode = document.createTextNode(newValue);
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode.setNodeValue(newValue);
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter(),
isAttributeSplittingDisabled());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection<org.w3c.dom.Node> textNodes = new ArrayList<org.w3c.dom.Node>();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (org.w3c.dom.Node tn : textNodes)
{
elem.removeChild(tn);
}
return result;
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0
"catch (Exception e)
",0
"reader = new InputStreamReader(in);
",0
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0
"synchronized (configs)
",0
private ConfigurationNode rootNode;,0
private final Object reloadLock;,0
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<?> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0
"catch (Exception ex)
",0
"return new Byte(n.byteValue());
",0
"catch (Exception e)
",0
"return new Float(n.floatValue());
",0
"return new Long(n.longValue());
",0
"return new Integer(n.intValue());
",0
"catch (Exception ex)
",0
"catch (Exception ex)
",0
private final String protocol;,0
"catch (Exception ex)
",0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0
"catch (Exception e)
",0
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
}
@Override
public ConfigurationInterpolator getInterpolator()
{
return parent.getInterpolator();
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"catch (Exception e)
",0
"catch (Exception ex)
",0
"catch (Exception e)
",0
private final QueryResult<T> attributeResult;,0
"writer = new OutputStreamWriter(out);
",0
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired = false;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public List getConfigurations()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getConfiguration());
}
return list;
}
public List getConfigurationNameList()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
synchronized(getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized(getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0
"if (file != null && file.exists())
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"catch (Exception ex)
",0
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
public Object getReloadLock()
{
return reloadLock;
",0
"instanceId = ++counter;
",0
private ReloadingStrategy fileStrategy;,0
"catch (Exception ex)
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
private final String protocol;,0
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0
"catch (Exception ex)
",0
public Token currentToken;,0
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0
"String key = null;
Object value = null;
Node node = new Node();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0
"Token token = null;
String value = null;
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
{if (true) return unescapeQuotes(removeQuotes(token.image));}
break;
case STRING:
token = jj_consume_token(STRING);
{if (true) return token.image;}
break;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0
"token = jj_consume_token(DATA);
{if (true) return filterData(token.image);}
",0
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0
public Token specialToken;,0
"addValue(Base64.decodeBase64(value.getBytes()));
",0
"staticCatalog = catalog;
",0
"List lst = (List) namedNodes.get(node.getName());
",0
"catch (Exception ex)
",0
"dump(configuration, new PrintWriter(out));
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"{
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0
"return bsCount % 2 == 1;
",0
"catch (Exception e)
",0
private DocumentBuilder documentBuilder;,0
"initProperty(bean, propName, properties.get(propName));
",0
"throw new IllegalArgumentException(""No such property name=["" + name + ""]"");
",0
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{if (true) return configuration;}
",0
"return null;
",0
"ReInit(stream);
SwitchTo(lexState);
}
",0
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0
"jjstateSet[jjnewStateCnt++] = jjnextStates[start];
}
while (start++ != end);
}
",0
public Token specialToken;,0
"public int beginLine, beginColumn, endLine, endColumn;",0
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0
"reader = new InputStreamReader(in);
",0
"PrintStream stream = new PrintStream(os);
",0
"getLogger().debug(os.toString());
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0
"private final StrLookup combinedConfigLookup = new StrLookup() {
@Override
public String lookup(String key) {
if (constructedConfiguration != null) {
Object value = constructedConfiguration.resolveContainerStore(key);
return (value != null) ? value.toString() : null;
}
return null;
}
};",0
"parent.mkdirs();
",0
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());,0
"return new Float(n.floatValue());
",0
"return new Byte(n.byteValue());
",0
"catch (Exception ex)
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
"getLogger().debug(os.toString());
",0
"ResultSet rs = pstmt.executeQuery();
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
private FileLocator locator;,0
"return new Float(n.floatValue());
",0
"catch (Exception ex)
",0
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0
"addValue(Base64.decodeBase64(value.getBytes()));
",0
"String name = (url == null) ? fileName : url.toString();
",0
private ConfigurationNode node;,0
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0
"pstmt = getConnection().prepareStatement(statement);
",0
"catch (Exception e)
",0
"catch (Exception e)
",0
"catch (Exception e)
",0
"catch (Exception ex)
",0
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0
"public class CombinedConfiguration extends HierarchicalReloadableConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private boolean ignoreReloadExceptions = true;
private boolean reloadRequired;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(NodeCombiner comb, Lock lock)
{
super(lock);
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration(Lock lock)
{
this(null, lock);
}
public CombinedConfiguration()
{
this(null, null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public boolean isIgnoreReloadExceptions()
{
return ignoreReloadExceptions;
}
public void setIgnoreReloadExceptions(boolean ignoreReloadExceptions)
{
this.ignoreReloadExceptions = ignoreReloadExceptions;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger().debug(""Adding configuration "" + config + "" with name "" + name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public List getConfigurations()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getConfiguration());
}
return list;
}
public List getConfigurationNameList()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
reloadRequired = true;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
synchronized (getReloadLock())
{
if (reloadRequired || combinedRoot == null)
{
combinedRoot = constructCombinedNode();
reloadRequired = false;
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
if (!ignoreReloadExceptions)
{
throw new ConfigurationRuntimeException(ex);
}
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
synchronized (getReloadLock())
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
}
return this;
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"ResultSet rs = pstmt.executeQuery();
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"ResultSet rs = pstmt.executeQuery();
",0
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0
private NodeCombiner nodeCombiner;,0
"if (configs != null)
",0
private final Object reloadLock;,0
"instanceId = ++counter;
",0
"catch (Exception ex)
",0
"if (init)
",0
"private static ThreadLocal recursive = new ThreadLocal()
{
protected synchronized Object initialValue()
{
return Boolean.FALSE;
}
};
private final Map configurationsMap = new HashMap();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
public void clear()
{
this.getConfiguration().clear();
}
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
public Iterator getKeys()
{
return this.getConfiguration().getKeys();
}
public Iterator getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
public List getList(String key, List defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
public List getList(String key)
{
return this.getConfiguration().getList(key);
}
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
public void addNodes(String key, Collection nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
public List configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
public Collection getConfigurationListeners()
{
return super.getConfigurationListeners();
}
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
public void clearErrorListeners()
{
super.clearErrorListeners();
}
public Collection getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
public void load() throws ConfigurationException
{
this.getConfiguration();
}
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
Iterator iter = getConfigurationListeners().iterator();
while (iter.hasNext())
{
ConfigurationListener listener = (ConfigurationListener) iter.next();
listener.configurationChanged(event);
}
}
}
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
Iterator iter = getErrorListeners().iterator();
while (iter.hasNext())
{
ConfigurationErrorListener listener = (ConfigurationErrorListener) iter.next();
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
protected Object resolveContainerStore(String key)
{
if (((Boolean) recursive.get()).booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
synchronized (configurationsMap)
{
configurationsMap.remove(path);
}
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
synchronized (configurationsMap)
{
if (configurationsMap.containsKey(path))
{
return (AbstractHierarchicalFileConfiguration) configurationsMap.get(path);
}
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
public void load() throws ConfigurationException
{
}
public void save() throws ConfigurationException
{
}
};
synchronized (configurationsMap)
{
configurationsMap.put(pattern, configuration);
}
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setAttributeSplittingDisabled(attributeSplittingDisabled);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
synchronized (configurationsMap)
{
if (!configurationsMap.containsKey(path))
{
configurationsMap.put(path, configuration);
}
}
return configuration;
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
"catch (Exception ex)
",0
private EntityResolver entityResolver = new DefaultEntityResolver();,0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0
"if (name == null)
",0
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0
"writer = new OutputStreamWriter(out);
",0
"PrintStream stream = new PrintStream(os);
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"ResultSet rs = pstmt.executeQuery();
",0
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0
"catch (Exception e)
",0
"synchronized (counterLock)
",0
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0
"catch (Exception e)
",0
"return new Byte(n.byteValue());
",0
"return new Double(n.doubleValue());
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
"catch (Exception ex)
",0
"{
super(name);
setReference(elem);
}
@Override
public void setValue(Object value)
{
super.setValue(value);
if (getReference() != null && document != null)
{
if (isAttribute())
{
updateAttribute();
}
else
{
updateElement(value);
}
}
}
@Override
protected void removeReference()
{
if (getReference() != null)
{
Element element = (Element) getReference();
if (isAttribute())
{
updateAttribute();
}
else
{
org.w3c.dom.Node parentElem = element.getParentNode();
if (parentElem != null)
{
parentElem.removeChild(element);
}
}
}
}
private void updateElement(Object value)
{
Text txtNode = findTextNodeForUpdate();
if (value == null)
{
if (txtNode != null)
{
((Element) getReference()).removeChild(txtNode);
}
}
else
{
if (txtNode == null)
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode = document.createTextNode(newValue);
if (((Element) getReference()).getFirstChild() != null)
{
((Element) getReference()).insertBefore(txtNode,
((Element) getReference()).getFirstChild());
}
else
{
((Element) getReference()).appendChild(txtNode);
}
}
else
{
String newValue = isDelimiterParsingDisabled() ? value.toString()
: PropertyConverter.escapeDelimiters(value.toString(), getListDelimiter());
txtNode.setNodeValue(newValue);
}
}
}
private void updateAttribute()
{
XMLBuilderVisitor.updateAttribute(getParent(), getName(), getListDelimiter(),
isAttributeSplittingDisabled());
}
private Text findTextNodeForUpdate()
{
Text result = null;
Element elem = (Element) getReference();
NodeList children = elem.getChildNodes();
Collection<org.w3c.dom.Node> textNodes = new ArrayList<org.w3c.dom.Node>();
for (int i = 0; i < children.getLength(); i++)
{
org.w3c.dom.Node nd = children.item(i);
if (nd instanceof Text)
{
if (result == null)
{
result = (Text) nd;
}
else
{
textNodes.add(nd);
}
}
}
if (result instanceof CDATASection)
{
textNodes.add(result);
result = null;
}
for (org.w3c.dom.Node tn : textNodes)
{
elem.removeChild(tn);
}
return result;
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
"catch (Exception e)
",0
"catch (Exception e)
",0
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""PropertyList-1.0.dtd""));
",0
"if (name == null)
",0
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0
"final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0
"dump(configuration, new PrintWriter(out));
",0
private final String protocol;,0
"catch (final Exception ex)
",0
"{
@Override
public InputSource resolveEntity(final String publicId, final String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0
"staticCatalog = catalog;
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
private final QueryResult<T> attributeResult;,0
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0
"reader = new InputStreamReader(in);
",0
"writer = new OutputStreamWriter(out);
",0
"public class CombinedConfiguration extends HierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private ConfigurationNode combinedRoot;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return namedConfigurations.get(name);
}
public List<AbstractConfiguration> getConfigurations()
{
List<AbstractConfiguration> list = new ArrayList<AbstractConfiguration>();
for (ConfigData config : configurations)
{
list.add(config.getConfiguration());
}
return list;
}
public List<String> getConfigurationNameList()
{
List<String> list = new ArrayList<String>();
for (ConfigData config : configurations)
{
list.add(config.getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if ((configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
synchronized (getNodeCombiner()) 
{
combinedRoot = null;
}
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (event.getType() == AbstractFileConfiguration.EVENT_CONFIG_CHANGED)
{
fireEvent(event.getType(), event.getPropertyName(), event.getPropertyValue(), event.isBeforeUpdate());
}
else if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
synchronized (getNodeCombiner())
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (ConfigData cd : configurations)
{
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Object getProperty(String key)
{
if (isForceReloadCheck())
{
for (ConfigData cd : configurations)
{
try
{
cd.getConfiguration().getProperty(PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
return super.getProperty(key);
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List<ConfigurationNode> nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator<ConfigurationNode> it = nodes.iterator();
Configuration source = findSourceConfiguration(it.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration(it.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key + "" is defined by multiple sources!"");
}
}
return source;
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
return new ViewNode();
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ConfigurationNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node, it.next().getTransformedRoot());
}
if (getLogger().isLoggable(Level.FINEST))
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().finest(os.toString());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (ConfigData cd : configurations)
{
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
",0
protected Configuration configuration;,0
"ResultSet rs = ps.executeQuery();
",0
"ResultSet rs = pstmt.executeQuery();
",0
"ResultSet rs = ps.executeQuery();
",0
"if (init)
",0
"return new Long(n.longValue());
",0
"T node2 = ((ConfigurationNodePointer<T>) pointer2).getConfigurationNode();
",0
"token = jj_consume_token(DATE);
{if (true) return parseDate(token.image);}
",0
"switch (i) {
case 0: jj_3_1(); break;
",0
"ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
",0
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (tabSize - (column % tabSize));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0
"List<ConfigurationNode> nodes = namedNodes.get(node.getName());
",0
"parent.mkdirs();
",0
"public class CombinedConfiguration extends HierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
combinedRoot = null;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"return count % 2 == 1;
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"ConfigurationDeclaration decl = (ConfigurationDeclaration) data;
",0
"switch (state)
{
case 0:
if (c == '\\')
{
state = 1;
}
else if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
key.append(c);
}
break;
case 1:
if (ArrayUtils.contains(SEPARATORS, c) || ArrayUtils.contains(WHITE_SPACE, c))
{
key.append(c);
}
else
{
key.append('\\');
key.append(c);
}
state = 0;
break;
case 2:
if (ArrayUtils.contains(WHITE_SPACE, c))
{
state = 2;
}
else if (ArrayUtils.contains(SEPARATORS, c))
{
state = 3;
}
else
{
value.append(c);
state = 3;
}
break;
case 3:
value.append(c);
",0
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"catch (Exception e)
",0
public Token currentToken;,0
"jj_input_stream.ReInit(stream, 1, 1);
token_source.ReInit(jj_input_stream);
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0
"switch (i) {
case 0: jj_3_1(); break;
",0
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0
"if (lexState >= 1 || lexState < 0)
{
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
}
else
{
curLexState = lexState;
}
}
",0
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0
"ReInit(dstream, 1, 1, 4096);
}
",0
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
}
",0
"public int beginLine, beginColumn, endLine, endColumn;",0
"String base64 = new String(Base64.encodeBase64((byte[]) value));
",0
"private StringBuffer buffer = new StringBuffer();
private List stack = new ArrayList();
public XMLPropertyListHandler(Node root)
{
push(root);
}
private Node peek()
{
if (!stack.isEmpty())
{
return (Node) stack.get(stack.size() - 1);
}
else
{
return null;
}
}
private Node pop()
{
if (!stack.isEmpty())
{
return (Node) stack.remove(stack.size() - 1);
}
else
{
return null;
}
}
private void push(Node node)
{
stack.add(node);
}
public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException
{
if (""array"".equals(qName))
{
push(new ArrayNode());
}
else if (""dict"".equals(qName))
{
if (peek() instanceof ArrayNode)
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) peek();
node.addValue(config);
push(config.getRoot());
}
}
}
public void endElement(String uri, String localName, String qName) throws SAXException
{
if (""key"".equals(qName))
{
PListNode node = new PListNode();
node.setName(buffer.toString());
peek().addChild(node);
push(node);
}
else if (""dict"".equals(qName))
{
pop();
}
else
{
if (""string"".equals(qName))
{
((PListNode) peek()).addValue(buffer.toString());
}
else if (""integer"".equals(qName))
{
((PListNode) peek()).addIntegerValue(buffer.toString());
}
else if (""real"".equals(qName))
{
((PListNode) peek()).addRealValue(buffer.toString());
}
else if (""true"".equals(qName))
{
((PListNode) peek()).addTrueValue();
}
else if (""false"".equals(qName))
{
((PListNode) peek()).addFalseValue();
}
else if (""data"".equals(qName))
{
((PListNode) peek()).addDataValue(buffer.toString());
}
else if (""date"".equals(qName))
{
((PListNode) peek()).addDateValue(buffer.toString());
}
else if (""array"".equals(qName))
{
ArrayNode array = (ArrayNode) pop();
((PListNode) peek()).addList(array);
}
if (!(peek() instanceof ArrayNode))
{
pop();
}
}
buffer.setLength(0);
}
public void characters(char[] ch, int start, int length) throws SAXException
{
buffer.append(ch, start, length);
}
",0
".get(positionToIndex(getPosition())));
",0
"dump(configuration, new PrintWriter(out));
",0
"return new ConfigurationBuilderResultCreatedEvent(this,
",0
private final String protocol;,0
"catch (Exception ex)
",0
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0
"catch (Exception e)
",0
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0
"return getFloat(key, new Float(defaultValue)).floatValue();
",0
"return getByte(key, new Byte(defaultValue)).byteValue();
",0
"return getLong(key, new Long(defaultValue)).longValue();
",0
"ResultSet rs = pstmt.executeQuery();
",0
"ResultSet rs = pstmt.executeQuery();
",0
"private Map<String, ConfigurationProvider> providers;",0
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0
"super();
reloadLock = new Lock(LOCK_NAME);
}
public HierarchicalReloadableConfiguration(Object lock)
{
super();
reloadLock = lock == null ? new Lock(LOCK_NAME) : lock;
}
public HierarchicalReloadableConfiguration(HierarchicalConfiguration c)
{
super(c);
reloadLock = new Lock(LOCK_NAME);
}
@Override
public Object getReloadLock()
{
return reloadLock;
",0
"instanceId = ++counter;
",0
"{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
",0
private ReloadingStrategy fileStrategy;,0
"configurationsMap.putIfAbsent(pattern, configuration);
",0
"if (init)
",0
"return new Long(n.longValue());
",0
"catch (Exception ex)
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"catch (Exception ex)
",0
"String name = (url == null) ? fileName : url.toString();
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
"List<ConfigurationNode> lst = namedNodes.get(node.getName());
",0
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0
"public class CombinedConfiguration extends BaseHierarchicalConfiguration implements
EventListener<ConfigurationEvent>, Cloneable
{
public static final EventType<ConfigurationEvent> COMBINED_INVALIDATE =
new EventType<ConfigurationEvent>(ConfigurationEvent.ANY,
""COMBINED_INVALIDATE"");
private static final DefaultExpressionEngine AT_ENGINE = DefaultExpressionEngine.INSTANCE;
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final ImmutableNode EMPTY_ROOT = new ImmutableNode.Builder()
.create();
private NodeCombiner nodeCombiner;
private List<ConfigData> configurations;
private Map<String, Configuration> namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean upToDate;
public CombinedConfiguration(NodeCombiner comb)
{
nodeCombiner = (comb != null) ? comb : DEFAULT_COMBINER;
initChildCollections();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
beginRead(true);
try
{
return nodeCombiner;
}
finally
{
endRead();
}
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
beginWrite(true);
try
{
this.nodeCombiner = nodeCombiner;
invalidateInternal();
}
finally
{
endWrite();
}
}
public ExpressionEngine getConversionExpressionEngine()
{
beginRead(true);
try
{
return conversionExpressionEngine;
}
finally
{
endRead();
}
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
beginWrite(true);
try
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
finally
{
endWrite();
}
}
public void addConfiguration(Configuration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
beginWrite(true);
try
{
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
if (getLogger().isDebugEnabled())
{
getLogger()
.debug(""Adding configuration "" + config + "" with name ""
+ name);
}
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
invalidateInternal();
}
finally
{
endWrite();
}
registerListenerAt(config);
}
public void addConfiguration(Configuration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(Configuration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
beginRead(true);
try
{
return getNumberOfConfigurationsInternal();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(int index)
{
beginRead(true);
try
{
ConfigData cd = configurations.get(index);
return cd.getConfiguration();
}
finally
{
endRead();
}
}
public Configuration getConfiguration(String name)
{
beginRead(true);
try
{
return namedConfigurations.get(name);
}
finally
{
endRead();
}
}
public List<Configuration> getConfigurations()
{
beginRead(true);
try
{
List<Configuration> list =
new ArrayList<Configuration>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getConfiguration());
}
return list;
}
finally
{
endRead();
}
}
public List<String> getConfigurationNameList()
{
beginRead(true);
try
{
List<String> list = new ArrayList<String>(getNumberOfConfigurationsInternal());
for (ConfigData cd : configurations)
{
list.add(cd.getName());
}
return list;
}
finally
{
endRead();
}
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (configurations.get(index).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
unregisterListenerAt(cd.getConfiguration());
invalidateInternal();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set<String> getConfigurationNames()
{
beginRead(true);
try
{
return namedConfigurations.keySet();
}
finally
{
endRead();
}
}
public void invalidate()
{
beginWrite(true);
try
{
invalidateInternal();
}
finally
{
endWrite();
}
}
@Override
public void onEvent(ConfigurationEvent event)
{
if (event.isBeforeUpdate())
{
invalidate();
}
}
@Override
protected void clearInternal()
{
unregisterListenerAtChildren();
initChildCollections();
invalidateInternal();
}
@Override
public Object clone()
{
beginRead(false);
try
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.initChildCollections();
for (ConfigData cd : configurations)
{
copy.addConfiguration(ConfigurationUtils.cloneConfiguration(cd
.getConfiguration()), cd.getName(), cd.getAt());
}
return copy;
}
finally
{
endRead();
}
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
Set<Configuration> sources = getSources(key);
if (sources.isEmpty())
{
return null;
}
Iterator<Configuration> iterator = sources.iterator();
Configuration source = iterator.next();
if (iterator.hasNext())
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
return source;
}
public Set<Configuration> getSources(String key)
{
beginRead(false);
try
{
List<QueryResult<ImmutableNode>> results = fetchNodeList(key);
Set<Configuration> sources = new HashSet<Configuration>();
for (QueryResult<ImmutableNode> result : results)
{
Set<Configuration> resultSources =
findSourceConfigurations(result.getNode());
if (resultSources.isEmpty())
{
sources.add(this);
}
else
{
sources.addAll(resultSources);
}
}
return sources;
}
finally
{
endRead();
}
}
@Override
protected void beginRead(boolean optimize)
{
if (optimize)
{
super.beginRead(true);
return;
}
boolean lockObtained = false;
do
{
super.beginRead(false);
if (isUpToDate())
{
lockObtained = true;
}
else
{
endRead();
beginWrite(false); 
endWrite();
}
} while (!lockObtained);
}
@Override
protected void beginWrite(boolean optimize)
{
super.beginWrite(true);
if (optimize)
{
return;
}
try
{
if (!isUpToDate())
{
getSubConfigurationParentModel().replaceRoot(
constructCombinedNode(), this);
upToDate = true;
}
}
catch (RuntimeException rex)
{
endWrite();
throw rex;
}
}
private boolean isUpToDate()
{
return upToDate;
}
private void invalidateInternal()
{
upToDate = false;
fireEvent(COMBINED_INVALIDATE, null, null, false);
}
private void initChildCollections()
{
configurations = new ArrayList<ConfigData>();
namedConfigurations = new HashMap<String, Configuration>();
}
private ImmutableNode constructCombinedNode()
{
if (getNumberOfConfigurationsInternal() < 1)
{
if (getLogger().isDebugEnabled())
{
getLogger().debug(""No configurations defined for "" + this);
}
return EMPTY_ROOT;
}
else
{
Iterator<ConfigData> it = configurations.iterator();
ImmutableNode node = it.next().getTransformedRoot();
while (it.hasNext())
{
node = nodeCombiner.combine(node,
it.next().getTransformedRoot());
}
if (getLogger().isDebugEnabled())
{
ByteArrayOutputStream os = new ByteArrayOutputStream();
PrintStream stream = new PrintStream(os);
TreeUtils.printTree(stream, node);
getLogger().debug(os.toString());
}
return node;
}
}
private Set<Configuration> findSourceConfigurations(ImmutableNode node)
{
Set<Configuration> result = new HashSet<Configuration>();
FindNodeVisitor<ImmutableNode> visitor =
new FindNodeVisitor<ImmutableNode>(node);
for (ConfigData cd : configurations)
{
NodeTreeWalker.INSTANCE.walkBFS(cd.getRootNode(), visitor,
getModel().getNodeHandler());
if (visitor.isFound())
{
result.add(cd.getConfiguration());
visitor.reset();
}
}
return result;
}
private void registerListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).addEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAt(Configuration configuration)
{
if (configuration instanceof EventSource)
{
((EventSource) configuration).removeEventListener(
ConfigurationEvent.ANY, this);
}
}
private void unregisterListenerAtChildren()
{
if (configurations != null)
{
for (ConfigData child : configurations)
{
unregisterListenerAt(child.getConfiguration());
}
}
}
private int getNumberOfConfigurationsInternal()
{
return configurations.size();
",0
"catch (Exception ex)
",0
private final ImmutableConfiguration configuration;,0
"return new Double(n.doubleValue());
",0
"staticCatalog = catalog;
",0
private final QueryResult<T> attributeResult;,0
"return getLong(key, new Long(defaultValue)).longValue();
",0
"value = array.length == 0 ? null : new Float(array[0]);
",0
"value = array.length == 0 ? null : new Short(array[0]);
",0
"writer = new OutputStreamWriter(out);
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"ResultSet rs = pstmt.executeQuery();
",0
"ResultSet rs = pstmt.executeQuery();
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"ResultSet rs = pstmt.executeQuery();
",0
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0
"return new Float(n.floatValue());
",0
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"getConfiguration().addProperty(name, new Long(array[i]));
",0
"getConfiguration().addProperty(name, new Double(array[i]));
",0
"getConfiguration().addProperty(name, new Short(array[i]));
",0
"return null;
",0
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true)
{
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
return configuration;
",0
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0
"public int beginLine, beginColumn, endLine, endColumn;",0
"return(""Lexical error at line "" +
",0
"{
public Object createObject(Attributes attributes) throws Exception
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) getDigester().peek();
node.addValue(config);
return config.getRoot();
",0
"{
public void end() throws Exception
{
}
",0
"List lst = (List) namedNodes.get(node.getName());
",0
private ConfigurationNode node;,0
"} catch (final Exception e) {
",0
"} catch (final Exception ex) {
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
"final ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0
"ResultSet rs = ps.executeQuery();
",0
"configurationsMap.putIfAbsent(pattern, configuration);
",0
"if (!init)
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0
"writer = new OutputStreamWriter(out);
",0
"reader = new InputStreamReader(in);
",0
"{
configuration = config;
name = n;
atPath = parseAt(at);
this.at = at;
}
public AbstractHierarchicalConfiguration<?> getConfiguration()
{
return configuration;
}
public String getName()
{
return name;
}
public String getAt()
{
return at;
}
public Object getRootNode()
{
return rootNode;
}
public CombinedNode getTransformedRoot()
{
CombinedNode result = new CombinedNode();
CombinedNode atParent = result;
if (atPath != null)
{
for (String name : atPath)
{
CombinedNode node = new CombinedNode();
node.setName(name);
atParent.addChild(name, node);
atParent = node;
}
}
rootNode = append(atParent, getConfiguration());
return result;
}
private <T> T append(CombinedNode atParent,
AbstractHierarchicalConfiguration<T> config)
{
T root = config.getRootNode();
atParent.appendChildren(root, config.getNodeHandler());
atParent.appendAttributes(root, config.getNodeHandler());
return root;
}
private Collection<String> parseAt(String at)
{
if (at == null)
{
return null;
}
Collection<String> result = new ArrayList<String>();
DefaultConfigurationKey.KeyIterator it = new DefaultConfigurationKey(
AT_ENGINE, at).iterator();
while (it.hasNext())
{
result.add(it.nextKey());
}
return result;
",0
"return new Byte(n.byteValue());
",0
"return new Float(n.floatValue());
",0
"return new Long(n.longValue());
",0
"return new Short(n.shortValue());
",0
private NodeHandler<T> nodeHandler;,0
"parent.mkdirs();
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
"catch (Exception ex)
",0
"catch (Exception e)
",0
"char[] ret = new char[len];
if ((bufpos + 1) >= len)
System.arraycopy(buffer, bufpos - len + 1, ret, 0, len);
else
{
System.arraycopy(buffer, bufsize - (len - bufpos - 1), ret, 0,
len - bufpos - 1);
System.arraycopy(buffer, 0, ret, len - bufpos - 1, bufpos + 1);
}
return ret;
",0
"ReInit(dstream, 1, 1, 4096);
}
",0
"ReInit(dstream, startline, startcolumn, 4096);
}
",0
"return(""Lexical error at line "" +
",0
"switch (i) {
case 0: jj_3_1(); break;
",0
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}
",0
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0
public int endColumn;,0
"return(""Lexical error at line "" +
",0
"String name = (url == null) ? fileName : url.toString();
",0
"result = namedNodes.get(name);
",0
"return getFloat(key, new Float(defaultValue)).floatValue();
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"file = new File(fileName);
",0
"ResultSet rs = pstmt.executeQuery();
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"{
@Override
protected Object interpolate(Object value)
{
return parent.interpolate(value);
",0
private ConfigurationNode rootNode;,0
private final Object reloadLock;,0
"configurationsMap.putIfAbsent(pattern, configuration);
",0
"private static ThreadLocal<Boolean> recursive = new ThreadLocal<Boolean>()
{
@Override
protected synchronized Boolean initialValue()
{
return Boolean.FALSE;
}
};
private final ConcurrentMap<String, XMLConfiguration> configurationsMap =
new ConcurrentHashMap<String, XMLConfiguration>();
private String pattern;
private boolean init;
private boolean ignoreException = true;
private boolean schemaValidation;
private boolean validating;
private boolean attributeSplittingDisabled;
private String loggerName = MultiFileHierarchicalConfiguration.class.getName();
private ReloadingStrategy fileStrategy;
private EntityResolver entityResolver;
private StrSubstitutor localSubst = new StrSubstitutor(new ConfigurationInterpolator());
public MultiFileHierarchicalConfiguration()
{
super();
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public MultiFileHierarchicalConfiguration(String pathPattern)
{
super();
this.pattern = pathPattern;
this.init = true;
setLogger(LogFactory.getLog(loggerName));
}
public void setLoggerName(String name)
{
this.loggerName = name;
}
public void setFilePattern(String pathPattern)
{
this.pattern = pathPattern;
}
public boolean isSchemaValidation()
{
return schemaValidation;
}
public void setSchemaValidation(boolean schemaValidation)
{
this.schemaValidation = schemaValidation;
}
public boolean isValidating()
{
return validating;
}
public void setValidating(boolean validating)
{
this.validating = validating;
}
public boolean isAttributeSplittingDisabled()
{
return attributeSplittingDisabled;
}
public void setAttributeSplittingDisabled(boolean attributeSplittingDisabled)
{
this.attributeSplittingDisabled = attributeSplittingDisabled;
}
@Override
public ReloadingStrategy getReloadingStrategy()
{
return fileStrategy;
}
@Override
public void setReloadingStrategy(ReloadingStrategy strategy)
{
this.fileStrategy = strategy;
}
public void setEntityResolver(EntityResolver entityResolver)
{
this.entityResolver = entityResolver;
}
public EntityResolver getEntityResolver()
{
return this.entityResolver;
}
public void setIgnoreException(boolean ignoreException)
{
this.ignoreException = ignoreException;
}
@Override
public void addProperty(String key, Object value)
{
this.getConfiguration().addProperty(key, value);
}
@Override
public void clear()
{
this.getConfiguration().clear();
}
@Override
public void clearProperty(String key)
{
this.getConfiguration().clearProperty(key);
}
@Override
public boolean containsKey(String key)
{
return this.getConfiguration().containsKey(key);
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return this.getConfiguration().getBigDecimal(key, defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return this.getConfiguration().getBigDecimal(key);
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return this.getConfiguration().getBigInteger(key, defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return this.getConfiguration().getBigInteger(key);
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return this.getConfiguration().getBoolean(key, defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return this.getConfiguration().getBoolean(key);
}
@Override
public byte getByte(String key, byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return this.getConfiguration().getByte(key, defaultValue);
}
@Override
public byte getByte(String key)
{
return this.getConfiguration().getByte(key);
}
@Override
public double getDouble(String key, double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return this.getConfiguration().getDouble(key, defaultValue);
}
@Override
public double getDouble(String key)
{
return this.getConfiguration().getDouble(key);
}
@Override
public float getFloat(String key, float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return this.getConfiguration().getFloat(key, defaultValue);
}
@Override
public float getFloat(String key)
{
return this.getConfiguration().getFloat(key);
}
@Override
public int getInt(String key, int defaultValue)
{
return this.getConfiguration().getInt(key, defaultValue);
}
@Override
public int getInt(String key)
{
return this.getConfiguration().getInt(key);
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return this.getConfiguration().getInteger(key, defaultValue);
}
@Override
public Iterator<String> getKeys()
{
return this.getConfiguration().getKeys();
}
@Override
public Iterator<String> getKeys(String prefix)
{
return this.getConfiguration().getKeys(prefix);
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return this.getConfiguration().getList(key, defaultValue);
}
@Override
public List<Object> getList(String key)
{
return this.getConfiguration().getList(key);
}
@Override
public long getLong(String key, long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return this.getConfiguration().getLong(key, defaultValue);
}
@Override
public long getLong(String key)
{
return this.getConfiguration().getLong(key);
}
@Override
public Properties getProperties(String key)
{
return this.getConfiguration().getProperties(key);
}
@Override
public Object getProperty(String key)
{
return this.getConfiguration().getProperty(key);
}
@Override
public short getShort(String key, short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return this.getConfiguration().getShort(key, defaultValue);
}
@Override
public short getShort(String key)
{
return this.getConfiguration().getShort(key);
}
@Override
public String getString(String key, String defaultValue)
{
return this.getConfiguration().getString(key, defaultValue);
}
@Override
public String getString(String key)
{
return this.getConfiguration().getString(key);
}
@Override
public String[] getStringArray(String key)
{
return this.getConfiguration().getStringArray(key);
}
@Override
public boolean isEmpty()
{
return this.getConfiguration().isEmpty();
}
@Override
public void setProperty(String key, Object value)
{
if (init)
{
this.getConfiguration().setProperty(key, value);
}
}
@Override
public Configuration subset(String prefix)
{
return this.getConfiguration().subset(prefix);
}
@Override
public Object getReloadLock()
{
return this.getConfiguration().getReloadLock();
}
@Override
public Node getRoot()
{
return this.getConfiguration().getRoot();
}
@Override
public void setRoot(Node node)
{
if (init)
{
this.getConfiguration().setRoot(node);
}
else
{
super.setRoot(node);
}
}
@Override
public ConfigurationNode getRootNode()
{
return this.getConfiguration().getRootNode();
}
@Override
public void setRootNode(ConfigurationNode rootNode)
{
if (init)
{
this.getConfiguration().setRootNode(rootNode);
}
else
{
super.setRootNode(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return super.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
super.setExpressionEngine(expressionEngine);
}
@Override
public void addNodes(String key, Collection<? extends ConfigurationNode> nodes)
{
this.getConfiguration().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return this.getConfiguration().configurationAt(key, supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return this.getConfiguration().configurationAt(key);
}
@Override
public List<HierarchicalConfiguration> configurationsAt(String key)
{
return this.getConfiguration().configurationsAt(key);
}
@Override
public void clearTree(String key)
{
this.getConfiguration().clearTree(key);
}
@Override
public int getMaxIndex(String key)
{
return this.getConfiguration().getMaxIndex(key);
}
@Override
public Configuration interpolatedConfiguration()
{
return this.getConfiguration().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
super.addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return super.removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return super.getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
super.clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
super.addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return super.removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
super.clearErrorListeners();
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return super.getErrorListeners();
}
public void save(Writer writer) throws ConfigurationException
{
if (init)
{
this.getConfiguration().save(writer);
}
}
public void load(Reader reader) throws ConfigurationException
{
if (init)
{
this.getConfiguration().load(reader);
}
}
@Override
public void load() throws ConfigurationException
{
this.getConfiguration();
}
@Override
public void load(String fileName) throws ConfigurationException
{
this.getConfiguration().load(fileName);
}
@Override
public void load(File file) throws ConfigurationException
{
this.getConfiguration().load(file);
}
@Override
public void load(URL url) throws ConfigurationException
{
this.getConfiguration().load(url);
}
@Override
public void load(InputStream in) throws ConfigurationException
{
this.getConfiguration().load(in);
}
@Override
public void load(InputStream in, String encoding) throws ConfigurationException
{
this.getConfiguration().load(in, encoding);
}
@Override
public void save() throws ConfigurationException
{
this.getConfiguration().save();
}
@Override
public void save(String fileName) throws ConfigurationException
{
this.getConfiguration().save(fileName);
}
@Override
public void save(File file) throws ConfigurationException
{
this.getConfiguration().save(file);
}
@Override
public void save(URL url) throws ConfigurationException
{
this.getConfiguration().save(url);
}
@Override
public void save(OutputStream out) throws ConfigurationException
{
this.getConfiguration().save(out);
}
@Override
public void save(OutputStream out, String encoding) throws ConfigurationException
{
this.getConfiguration().save(out, encoding);
}
@Override
public void configurationChanged(ConfigurationEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationListener listener : getConfigurationListeners())
{
listener.configurationChanged(event);
}
}
}
@Override
public void configurationError(ConfigurationErrorEvent event)
{
if (event.getSource() instanceof XMLConfiguration)
{
for (ConfigurationErrorListener listener : getErrorListeners())
{
listener.configurationError(event);
}
}
if (event.getType() == AbstractFileConfiguration.EVENT_RELOAD)
{
if (isThrowable(event.getCause()))
{
throw new ConfigurationRuntimeException(event.getCause());
}
}
}
@Override
protected Object resolveContainerStore(String key)
{
if (recursive.get().booleanValue())
{
return null;
}
recursive.set(Boolean.TRUE);
try
{
return super.resolveContainerStore(key);
}
finally
{
recursive.set(Boolean.FALSE);
}
}
public void removeConfiguration()
{
String path = getSubstitutor().replace(pattern);
configurationsMap.remove(path);
}
private AbstractHierarchicalFileConfiguration getConfiguration()
{
if (pattern == null)
{
throw new ConfigurationRuntimeException(""File pattern must be defined"");
}
String path = localSubst.replace(pattern);
if (configurationsMap.containsKey(path))
{
return configurationsMap.get(path);
}
if (path.equals(pattern))
{
XMLConfiguration configuration = new XMLConfiguration()
{
@Override
public void load() throws ConfigurationException
{
}
@Override
public void save() throws ConfigurationException
{
}
};
configurationsMap.putIfAbsent(pattern, configuration);
return configuration;
}
XMLConfiguration configuration = new XMLConfiguration();
if (loggerName != null)
{
Log log = LogFactory.getLog(loggerName);
if (log != null)
{
configuration.setLogger(log);
}
}
configuration.setBasePath(getBasePath());
configuration.setFileName(path);
configuration.setFileSystem(getFileSystem());
configuration.setExpressionEngine(getExpressionEngine());
ReloadingStrategy strategy = createReloadingStrategy();
if (strategy != null)
{
configuration.setReloadingStrategy(strategy);
}
configuration.setDelimiterParsingDisabled(isDelimiterParsingDisabled());
configuration.setAttributeSplittingDisabled(isAttributeSplittingDisabled());
configuration.setValidating(validating);
configuration.setSchemaValidation(schemaValidation);
configuration.setEntityResolver(entityResolver);
configuration.setListDelimiter(getListDelimiter());
configuration.addConfigurationListener(this);
configuration.addErrorListener(this);
try
{
configuration.load();
}
catch (ConfigurationException ce)
{
if (isThrowable(ce))
{
throw new ConfigurationRuntimeException(ce);
}
}
configurationsMap.putIfAbsent(path, configuration);
return configurationsMap.get(path);
}
private boolean isThrowable(Throwable throwable)
{
if (!ignoreException)
{
return true;
}
Throwable cause = throwable.getCause();
while (cause != null && !(cause instanceof SAXParseException))
{
cause = cause.getCause();
}
return cause != null;
}
private ReloadingStrategy createReloadingStrategy()
{
if (fileStrategy == null)
{
return null;
}
try
{
ReloadingStrategy strategy = (ReloadingStrategy) BeanUtils.cloneBean(fileStrategy);
strategy.setConfiguration(null);
return strategy;
}
catch (Exception ex)
{
return null;
",0
"return new Short(n.shortValue());
",0
"return new Double(n.doubleValue());
",0
"catch (Exception ex)
",0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
"catch (Exception ex)
",0
"addValue(Base64.decodeBase64(value.getBytes()));
",0
"if (name == null)
",0
private ConfigurationNode node;,0
"public class CombinedConfiguration extends HierarchicalConfiguration implements
ConfigurationListener, Cloneable
{
public static final int EVENT_COMBINED_INVALIDATE = 40;
private static final long serialVersionUID = 8338574525528692307L;
private static final DefaultExpressionEngine AT_ENGINE = new DefaultExpressionEngine();
private static final NodeCombiner DEFAULT_COMBINER = new UnionCombiner();
private static final String PROP_RELOAD_CHECK = ""CombinedConfigurationReloadCheck"";
private NodeCombiner nodeCombiner;
private volatile ConfigurationNode combinedRoot;
private List configurations;
private Map namedConfigurations;
private ExpressionEngine conversionExpressionEngine;
private boolean forceReloadCheck;
public CombinedConfiguration(NodeCombiner comb)
{
setNodeCombiner((comb != null) ? comb : DEFAULT_COMBINER);
clear();
}
public CombinedConfiguration()
{
this(null);
}
public NodeCombiner getNodeCombiner()
{
return nodeCombiner;
}
public void setNodeCombiner(NodeCombiner nodeCombiner)
{
if (nodeCombiner == null)
{
throw new IllegalArgumentException(
""Node combiner must not be null!"");
}
this.nodeCombiner = nodeCombiner;
invalidate();
}
public boolean isForceReloadCheck()
{
return forceReloadCheck;
}
public void setForceReloadCheck(boolean forceReloadCheck)
{
this.forceReloadCheck = forceReloadCheck;
}
public ExpressionEngine getConversionExpressionEngine()
{
return conversionExpressionEngine;
}
public void setConversionExpressionEngine(
ExpressionEngine conversionExpressionEngine)
{
this.conversionExpressionEngine = conversionExpressionEngine;
}
public void addConfiguration(AbstractConfiguration config, String name,
String at)
{
if (config == null)
{
throw new IllegalArgumentException(
""Added configuration must not be null!"");
}
if (name != null && namedConfigurations.containsKey(name))
{
throw new ConfigurationRuntimeException(
""A configuration with the name '""
+ name
+ ""' already exists in this combined configuration!"");
}
ConfigData cd = new ConfigData(config, name, at);
configurations.add(cd);
if (name != null)
{
namedConfigurations.put(name, config);
}
config.addConfigurationListener(this);
invalidate();
}
public void addConfiguration(AbstractConfiguration config, String name)
{
addConfiguration(config, name, null);
}
public void addConfiguration(AbstractConfiguration config)
{
addConfiguration(config, null, null);
}
public int getNumberOfConfigurations()
{
return configurations.size();
}
public Configuration getConfiguration(int index)
{
ConfigData cd = (ConfigData) configurations.get(index);
return cd.getConfiguration();
}
public Configuration getConfiguration(String name)
{
return (Configuration) namedConfigurations.get(name);
}
public List getConfigurations()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getConfiguration());
}
return list;
}
public List getConfigurationNameList()
{
List list = new ArrayList();
Iterator iter = configurations.iterator();
while (iter.hasNext())
{
list.add(((ConfigData) iter.next()).getName());
}
return list;
}
public boolean removeConfiguration(Configuration config)
{
for (int index = 0; index < getNumberOfConfigurations(); index++)
{
if (((ConfigData) configurations.get(index)).getConfiguration() == config)
{
removeConfigurationAt(index);
return true;
}
}
return false;
}
public Configuration removeConfigurationAt(int index)
{
ConfigData cd = (ConfigData) configurations.remove(index);
if (cd.getName() != null)
{
namedConfigurations.remove(cd.getName());
}
cd.getConfiguration().removeConfigurationListener(this);
invalidate();
return cd.getConfiguration();
}
public Configuration removeConfiguration(String name)
{
Configuration conf = getConfiguration(name);
if (conf != null)
{
removeConfiguration(conf);
}
return conf;
}
public Set getConfigurationNames()
{
return namedConfigurations.keySet();
}
public void invalidate()
{
combinedRoot = null;
fireEvent(EVENT_COMBINED_INVALIDATE, null, null, false);
}
public void configurationChanged(ConfigurationEvent event)
{
if (!event.isBeforeUpdate())
{
invalidate();
}
}
public ConfigurationNode getRootNode()
{
if (combinedRoot == null)
{
combinedRoot = constructCombinedNode();
}
return combinedRoot;
}
public void clear()
{
fireEvent(EVENT_CLEAR, null, null, true);
configurations = new ArrayList();
namedConfigurations = new HashMap();
fireEvent(EVENT_CLEAR, null, null, false);
invalidate();
}
public Object clone()
{
CombinedConfiguration copy = (CombinedConfiguration) super.clone();
copy.clear();
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
copy.addConfiguration((AbstractConfiguration) ConfigurationUtils
.cloneConfiguration(cd.getConfiguration()), cd.getName(),
cd.getAt());
}
copy.setRootNode(new DefaultConfigurationNode());
return copy;
}
public Configuration getSource(String key)
{
if (key == null)
{
throw new IllegalArgumentException(""Key must not be null!"");
}
List nodes = fetchNodeList(key);
if (nodes.isEmpty())
{
return null;
}
Iterator it = nodes.iterator();
Configuration source = findSourceConfiguration((ConfigurationNode) it
.next());
while (it.hasNext())
{
Configuration src = findSourceConfiguration((ConfigurationNode) it
.next());
if (src != source)
{
throw new IllegalArgumentException(""The key "" + key
+ "" is defined by multiple sources!"");
}
}
return source;
}
protected List fetchNodeList(String key)
{
if (isForceReloadCheck())
{
performReloadCheck();
}
return super.fetchNodeList(key);
}
protected void performReloadCheck()
{
for (Iterator it = configurations.iterator(); it.hasNext();)
{
try
{
((ConfigData) it.next()).getConfiguration().getProperty(
PROP_RELOAD_CHECK);
}
catch (Exception ex)
{
;
}
}
}
private ConfigurationNode constructCombinedNode()
{
if (getNumberOfConfigurations() < 1)
{
return new ViewNode();
}
else
{
Iterator it = configurations.iterator();
ConfigurationNode node = ((ConfigData) it.next())
.getTransformedRoot();
while (it.hasNext())
{
node = getNodeCombiner().combine(node,
((ConfigData) it.next()).getTransformedRoot());
}
return node;
}
}
private Configuration findSourceConfiguration(ConfigurationNode node)
{
ConfigurationNode root = null;
ConfigurationNode current = node;
while (current != null)
{
root = current;
current = current.getParentNode();
}
for (Iterator it = configurations.iterator(); it.hasNext();)
{
ConfigData cd = (ConfigData) it.next();
if (root == cd.getRootNode())
{
return cd.getConfiguration();
}
}
return this;
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"if (filename != null && filename.toLowerCase().trim().endsWith("".xml""))
",0
"if (file != null && file.exists())
",0
protected Configuration configuration;,0
"ResultSet rs = pstmt.executeQuery();
",0
"{
public void load() throws ConfigurationException
{
}
public void save() throws ConfigurationException
{
}
",0
"catch (Exception e)
",0
"{
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
public Token currentToken;,0
"return null;
",0
"PropertyListConfiguration configuration = new PropertyListConfiguration();
List children = new ArrayList();
Node child = null;
jj_consume_token(DICT_BEGIN);
label_1:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case STRING:
case QUOTED_STRING:
;
break;
default:
jj_la1[0] = jj_gen;
break label_1;
}
child = Property();
if (child.getValue() instanceof HierarchicalConfiguration)
{
HierarchicalConfiguration conf = (HierarchicalConfiguration) child.getValue();
Node root = conf.getRoot();
root.setName(child.getName());
children.add(root);
}
else
{
children.add(child);
}
}
jj_consume_token(DICT_END);
for (int i = 0; i < children.size(); i++)
{
child = (Node) children.get(i);
configuration.getRoot().addChild(child);
}
{if (true) return configuration;}
",0
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case DATE:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
{if (true) return list;}
",0
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0
"ReInit(dstream, startline, startcolumn, 4096);
}
",0
public Token specialToken;,0
"public int beginLine, beginColumn, endLine, endColumn;",0
"// [ERROR] Medium: Class org.apache.commons.configuration2.builder.ConfigurationBuilderResultCreatedEvent defines
private final ImmutableConfiguration configuration;",0
"return getDouble(key, new Double(defaultValue)).doubleValue();
",0
"value = array.length == 0 ? null : new Byte(array[0]);
",0
"return getShort(key, new Short(defaultValue)).shortValue();
",0
private ConfigurationNode combinedRoot;,0
"ResultSet rs = pstmt.executeQuery();
",0
"ResultSet rs = pstmt.executeQuery();
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"return new Integer(n.intValue());
",0
"return new Float(n.floatValue());
",0
"{
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0
"initProperty(bean, propName, properties.get(propName));
",0
"getConfiguration().addProperty(name, new Integer(array[i]));
",0
"Node node = new Node();
String key = String();
node.setName(key);
jj_consume_token(EQUAL);
Object value = Element();
node.setValue(value);
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
return node;
",0
"return null;
",0
"if ((jjbitVec0[i2] & l2) == 0L)
break;
if (kind > 19)
kind = 19;
jjCheckNAdd(3);
break;
",0
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0
"public int beginLine, beginColumn, endLine, endColumn;",0
"{
public Object createObject(Attributes attributes) throws Exception
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) getDigester().peek();
node.addValue(config);
return config.getRoot();
",0
"return (configuration.getURL() != null) ? fileFromURL(configuration
",0
"result = (List) namedNodes.get(name);
",0
"return reverse ? getStartOffset() + 1 : subNodes.size()
",0
".get(positionToIndex(getPosition())));
",0
private final Configuration configuration;,0
private final String protocol;,0
"staticCatalog = catalog;
",0
"ResultSet rs = pstmt.executeQuery();
",0
private NodeCombiner nodeCombiner;,0
"{
this.config = config;
this.path = path;
this.trailing = path.endsWith(""/"");
this.init = true;
}
@Override
protected void addPropertyInternal(String key, Object value)
{
config.addProperty(makePath(key), value);
}
@Override
protected void clearInternal()
{
getConfig().clear();
}
@Override
protected void clearPropertyDirect(String key)
{
config.clearProperty(makePath(key));
}
@Override
protected boolean containsKeyInternal(String key)
{
return config.containsKey(makePath(key));
}
@Override
public BigDecimal getBigDecimal(String key, BigDecimal defaultValue)
{
return config.getBigDecimal(makePath(key), defaultValue);
}
@Override
public BigDecimal getBigDecimal(String key)
{
return config.getBigDecimal(makePath(key));
}
@Override
public BigInteger getBigInteger(String key, BigInteger defaultValue)
{
return config.getBigInteger(makePath(key), defaultValue);
}
@Override
public BigInteger getBigInteger(String key)
{
return config.getBigInteger(makePath(key));
}
@Override
public boolean getBoolean(String key, boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public Boolean getBoolean(String key, Boolean defaultValue)
{
return config.getBoolean(makePath(key), defaultValue);
}
@Override
public boolean getBoolean(String key)
{
return config.getBoolean(makePath(key));
}
@Override
public byte getByte(String key, byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public Byte getByte(String key, Byte defaultValue)
{
return config.getByte(makePath(key), defaultValue);
}
@Override
public byte getByte(String key)
{
return config.getByte(makePath(key));
}
@Override
public double getDouble(String key, double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public Double getDouble(String key, Double defaultValue)
{
return config.getDouble(makePath(key), defaultValue);
}
@Override
public double getDouble(String key)
{
return config.getDouble(makePath(key));
}
@Override
public float getFloat(String key, float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public Float getFloat(String key, Float defaultValue)
{
return config.getFloat(makePath(key), defaultValue);
}
@Override
public float getFloat(String key)
{
return config.getFloat(makePath(key));
}
@Override
public int getInt(String key, int defaultValue)
{
return config.getInt(makePath(key), defaultValue);
}
@Override
public int getInt(String key)
{
return config.getInt(makePath(key));
}
@Override
public Integer getInteger(String key, Integer defaultValue)
{
return config.getInteger(makePath(key), defaultValue);
}
@Override
protected Iterator<String> getKeysInternal()
{
return config.getKeys(makePath());
}
@Override
protected Iterator<String> getKeysInternal(String prefix)
{
return config.getKeys(makePath(prefix));
}
@Override
public List<Object> getList(String key, List<Object> defaultValue)
{
return config.getList(makePath(key), defaultValue);
}
@Override
public List<Object> getList(String key)
{
return config.getList(makePath(key));
}
@Override
public long getLong(String key, long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public Long getLong(String key, Long defaultValue)
{
return config.getLong(makePath(key), defaultValue);
}
@Override
public long getLong(String key)
{
return config.getLong(makePath(key));
}
@Override
public Properties getProperties(String key)
{
return config.getProperties(makePath(key));
}
@Override
protected Object getPropertyInternal(String key)
{
return config.getProperty(makePath(key));
}
@Override
public short getShort(String key, short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public Short getShort(String key, Short defaultValue)
{
return config.getShort(makePath(key), defaultValue);
}
@Override
public short getShort(String key)
{
return config.getShort(makePath(key));
}
@Override
public String getString(String key, String defaultValue)
{
return config.getString(makePath(key), defaultValue);
}
@Override
public String getString(String key)
{
return config.getString(makePath(key));
}
@Override
public String[] getStringArray(String key)
{
return config.getStringArray(makePath(key));
}
@Override
protected boolean isEmptyInternal()
{
return getConfig().isEmpty();
}
@Override
protected void setPropertyInternal(String key, Object value)
{
getConfig().setProperty(key, value);
}
@Override
public Configuration subset(String prefix)
{
return getConfig().subset(prefix);
}
@Override
public ConfigurationNode getRootNode()
{
return getConfig().getRootNode();
}
@Override
protected void setRootNodeInternal(ConfigurationNode rootNode)
{
if (init)
{
getConfig().setRootNode(rootNode);
}
else
{
super.setRootNodeInternal(rootNode);
}
}
@Override
public ExpressionEngine getExpressionEngine()
{
return config.getExpressionEngine();
}
@Override
public void setExpressionEngine(ExpressionEngine expressionEngine)
{
if (init)
{
config.setExpressionEngine(expressionEngine);
}
else
{
super.setExpressionEngine(expressionEngine);
}
}
@Override
protected void addNodesInternal(String key, Collection<? extends ConfigurationNode> nodes)
{
getConfig().addNodes(key, nodes);
}
@Override
public SubnodeConfiguration configurationAt(String key, boolean supportUpdates)
{
return config.configurationAt(makePath(key), supportUpdates);
}
@Override
public SubnodeConfiguration configurationAt(String key)
{
return config.configurationAt(makePath(key));
}
@Override
public List<SubnodeConfiguration> configurationsAt(String key)
{
return config.configurationsAt(makePath(key));
}
@Override
protected List<ConfigurationNode> clearTreeInternal(String key)
{
config.clearTree(makePath(key));
return Collections.emptyList();
}
@Override
protected int getMaxIndexInternal(String key)
{
return config.getMaxIndex(makePath(key));
}
@Override
public Configuration interpolatedConfiguration()
{
return getConfig().interpolatedConfiguration();
}
@Override
public void addConfigurationListener(ConfigurationListener l)
{
getConfig().addConfigurationListener(l);
}
@Override
public boolean removeConfigurationListener(ConfigurationListener l)
{
return getConfig().removeConfigurationListener(l);
}
@Override
public Collection<ConfigurationListener> getConfigurationListeners()
{
return getConfig().getConfigurationListeners();
}
@Override
public void clearConfigurationListeners()
{
getConfig().clearConfigurationListeners();
}
@Override
public void addErrorListener(ConfigurationErrorListener l)
{
getConfig().addErrorListener(l);
}
@Override
public boolean removeErrorListener(ConfigurationErrorListener l)
{
return getConfig().removeErrorListener(l);
}
@Override
public void clearErrorListeners()
{
getConfig().clearErrorListeners();
}
public void write(Writer writer) throws ConfigurationException, IOException
{
fetchFileBased().write(writer);
}
public void read(Reader reader) throws ConfigurationException, IOException
{
fetchFileBased().read(reader);
}
@Override
public Collection<ConfigurationErrorListener> getErrorListeners()
{
return getConfig().getErrorListeners();
}
private BaseHierarchicalConfiguration getConfig()
{
return config.configurationAt(makePath());
}
private String makePath()
{
String pathPattern = trailing ? path.substring(0, path.length() - 1) : path;
return substitute(pathPattern);
}
private String makePath(String item)
{
String pathPattern;
if ((item.length() == 0 || item.startsWith(""/"")) && trailing)
{
pathPattern = path.substring(0, path.length() - 1);
}
else  if (!item.startsWith(""/"") || !trailing)
{
pathPattern = path + ""/"";
}
else
{
pathPattern = path;
}
return substitute(pathPattern) + item;
}
private String substitute(String pattern)
{
Object value = getInterpolator().interpolate(pattern);
return (value != null) ? value.toString() : null;
}
private FileBased fetchFileBased() throws ConfigurationException
{
if (!(config instanceof FileBased))
{
throw new ConfigurationException(
""Wrapped configuration does not implement FileBased!""
+ "" No I/O operations are supported."");
}
return (FileBased) config;
",0
"catch (Exception e)
",0
private ConfigurationSourceData sourceData;,0
"return new Long(n.longValue());
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
"return createNodePointer(subNodes.get(positionToIndex(getPosition())));
",0
"getLogger().debug(os.toString());
",0
"dump(configuration, new PrintWriter(out));
",0
"catch (Exception ex)
",0
"catch (Exception e)
",0
"catch (Exception ex)
",0
"return new ConfigurationBuilderResultCreatedEvent(this,
",0
"return new Byte(n.byteValue());
",0
private final EventType<? extends Event> eventType;,0
"catch (Exception ex)
",0
"catch (Exception e)
",0
"String name = (url == null) ? fileName : url.toString();
",0
"final ReferenceNodeHandler refHandler = (ReferenceNodeHandler) handler;
",0
"dump(configuration, new PrintWriter(out));
",0
"return new ConfigurationBuilderResultCreatedEvent(this, ConfigurationBuilderResultCreatedEvent.RESULT_CREATED,
",0
"reloadingController.resetReloadingState();
",0
"} catch (final Exception e) {
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
"staticCatalog = catalog;
",0
private final NodeHandler<T> handler;,0
"getLogger().debug(os.toString());
",0
"catch (Exception ex)
",0
private final ConversionHandler dataConversionHandler;,0
private Document document;,0
private EntityResolver entityResolver = new DefaultEntityResolver();,0
"return additionalBeanInfo;
",0
private ReloadingController reloadingController;,0
"return new Short(n.shortValue());
",0
"parent.mkdirs();
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
"catch (Exception e)
",0
"ConfigurationInterpolator ci = ((CatalogManager) catalogManager).getInterpolator();
",0
"List<ConfigurationNode> lst = namedNodes.remove(name);
",0
"writer = new OutputStreamWriter(out);
",0
"reader = new InputStreamReader(in);
",0
protected Configuration configuration;,0
"pstmt = conn.prepareStatement(query.toString());
",0
"catch (Exception e)
",0
"catch (Exception e)
",0
"expected += tokenImage[expectedTokenSequences[i][j]] + "" "";
",0
"String key = null;
Object value = null;
Node node = new Node();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0
"token_source = tm;
token = new Token();
jj_ntk = -1;
jj_gen = 0;
for (int i = 0; i < 6; i++) jj_la1[i] = -1;
for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
}
",0
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0
"if (maxNextCharInd == available)
{
if (available == bufsize)
{
if (tokenBegin > 2048)
{
bufpos = maxNextCharInd = 0;
available = tokenBegin;
}
else if (tokenBegin < 0)
bufpos = maxNextCharInd = 0;
else
ExpandBuff(false);
}
else if (available > tokenBegin)
available = bufsize;
else if ((tokenBegin - available) < 2048)
ExpandBuff(true);
else
available = tokenBegin;
}
int i;
try {
if ((i = inputStream.read(buffer, maxNextCharInd,
available - maxNextCharInd)) == -1)
{
inputStream.close();
throw new java.io.IOException();
}
else
maxNextCharInd += i;
return;
}
catch(java.io.IOException e) {
--bufpos;
backup(0);
if (tokenBegin == -1)
tokenBegin = bufpos;
throw e;
",0
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0
"char[] newbuffer = new char[bufsize + 2048];
int newbufline[] = new int[bufsize + 2048];
int newbufcolumn[] = new int[bufsize + 2048];
try
{
if (wrapAround)
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
System.arraycopy(buffer, 0, newbuffer,
bufsize - tokenBegin, bufpos);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
System.arraycopy(bufline, 0, newbufline, bufsize - tokenBegin, bufpos);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
System.arraycopy(bufcolumn, 0, newbufcolumn, bufsize - tokenBegin, bufpos);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos += (bufsize - tokenBegin));
}
else
{
System.arraycopy(buffer, tokenBegin, newbuffer, 0, bufsize - tokenBegin);
buffer = newbuffer;
System.arraycopy(bufline, tokenBegin, newbufline, 0, bufsize - tokenBegin);
bufline = newbufline;
System.arraycopy(bufcolumn, tokenBegin, newbufcolumn, 0, bufsize - tokenBegin);
bufcolumn = newbufcolumn;
maxNextCharInd = (bufpos -= tokenBegin);
}
}
catch (Throwable t)
{
throw new Error(t.getMessage());
}
bufsize += 2048;
available = bufsize;
tokenBegin = 0;
}
",0
"column++;
if (prevCharIsLF)
{
prevCharIsLF = false;
line += (column = 1);
}
else if (prevCharIsCR)
{
prevCharIsCR = false;
if (c == '\n')
{
prevCharIsLF = true;
}
else
line += (column = 1);
}
switch (c)
{
case '\r' :
prevCharIsCR = true;
break;
case '\n' :
prevCharIsLF = true;
break;
case '\t' :
column--;
column += (8 - (column & 07));
break;
default :
break;
}
bufline[bufpos] = line;
bufcolumn[bufpos] = column;
}
",0
"public int beginLine, beginColumn, endLine, endColumn;",0
"List lst = (List) namedNodes.get(node.getName());
",0
"return getShort(key, new Short(defaultValue)).shortValue();
",0
"value = array.length == 0 ? null : new Double(array[0]);
",0
"writer = new OutputStreamWriter(out);
",0
"parent.mkdirs();
",0
private ConfigurationNode combinedRoot;,0
"ResultSet rs = pstmt.executeQuery();
",0
"pstmt = conn.prepareStatement(query.toString());
",0
"return new Float(n.floatValue());
",0
"getConfiguration().addProperty(name, new Long(array[i]));
",0
"getConfiguration().addProperty(name, new Short(array[i]));
",0
"getConfiguration().addProperty(name, new Float(array[i]));
",0
"getConfiguration().addProperty(name, new Double(array[i]));
",0
"switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case ARRAY_BEGIN:
return Array();
case DICT_BEGIN:
return Dictionary();
case STRING:
case QUOTED_STRING:
return String();
case DATA:
return Data();
default:
jj_la1[2] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0
"Token token = null;
switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk)
{
case QUOTED_STRING:
token = jj_consume_token(QUOTED_STRING);
return unescapeQuotes(removeQuotes(token.image));
case STRING:
token = jj_consume_token(STRING);
return token.image;
default:
jj_la1[5] = jj_gen;
jj_consume_token(-1);
throw new ParseException();
",0
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0
"inputStream = dstream;
line = startline;
column = startcolumn - 1;
if (buffer == null || buffersize != buffer.length)
{
available = bufsize = buffersize;
buffer = new char[buffersize];
bufline = new int[buffersize];
bufcolumn = new int[buffersize];
}
prevCharIsLF = prevCharIsCR = false;
tokenBegin = inBuf = maxNextCharInd = 0;
bufpos = -1;
}
",0
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
",0
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0
public Token specialToken;,0
"public int beginLine, beginColumn, endLine, endColumn;",0
"{
public Object createObject(Attributes attributes) throws Exception
{
XMLPropertyListConfiguration config = new XMLPropertyListConfiguration();
ArrayNode node = (ArrayNode) getDigester().peek();
node.addValue(config);
return config.getRoot();
",0
"addValue(format.parse(value));
",0
"result = (List) namedNodes.get(name);
",0
"pstmt = getConnection().prepareStatement(statement);
",0
private ReloadingController reloadingController;,0
"catch (Exception e)
",0
private final QueryResult<T> attributeResult;,0
"return new ConfigurationNodePointer((ConfigurationNodePointer) parent,
",0
"writer = new OutputStreamWriter(out);
",0
private List<ConfigData> configurations;,0
"dump(configuration, new PrintWriter(out));
",0
"pstmt = conn.prepareStatement(query.toString());
",0
private ConfigurationNode rootNode;,0
private ReloadingStrategy fileStrategy;,0
"if (init)
",0
"return new Short(n.shortValue());
",0
"catch (Exception e)
",0
"String methodName = ""set"" + key.substring(0, 1).toUpperCase() + key.substring(1);
",0
"catch (Exception ex)
",0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
"catch (Exception e)
",0
"SubnodeConfiguration config = (SubnodeConfiguration) iter.next();
",0
"StrSubstitutor substitutor = ((CatalogManager) catalogManager).getStrSubstitutor();
",0
"String name = (url == null) ? fileName : url.toString();
",0
"staticCatalog = catalog;
",0
"result = namedNodes.get(name);
",0
"pstmt = getConnection().prepareStatement(statement);
",0
"{
@Override
public void error(final SAXParseException ex) throws SAXException
{
throw ex;
",0
"catch (final Exception e)
",0
private final ImmutableConfiguration configuration;,0
private ConfigurationSourceData sourceData;,0
"return new Double(n.doubleValue());
",0
private final String protocol;,0
"return getFloat(key, new Float(defaultValue));
",0
"dump(configuration, new PrintWriter(out));
",0
"ResultSet rs = pstmt.executeQuery();
",0
"&& fileName.toLowerCase().trim().endsWith(fileExtension))
",0
"if (init)
",0
"String encoding = getEncoding() != null ? getEncoding() : DEFAULT_ENCODING;
",0
"catch (Exception ex)
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"PrintStream stream = new PrintStream(os);
",0
"catch (Exception e)
",0
"Token token = null;
token = jj_consume_token(STRING);
{if (true) return StringEscapeUtils.unescapeJava(removeQuotes(token.image));}
",0
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0
"if (lexState >= 1 || lexState < 0)
throw new TokenMgrError(""Error: Ignoring invalid lexical state : "" + lexState + "". State unchanged."", TokenMgrError.INVALID_LEXICAL_STATE);
else
curLexState = lexState;
}
",0
"jjround = 0x80000001;
for (i = 31; i-- > 0;)
jjrounds[i] = 0x80000000;
}
",0
public Token currentToken;,0
"this(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0
"ReInit(dstream, 1, 1, 4096);
}
",0
"buffer = null;
bufline = null;
bufcolumn = null;
}
",0
"tokenBegin = -1;
char c = readChar();
tokenBegin = bufpos;
return c;
",0
"ReInit(dstream, 1, 1, 4096);
}
",0
"return instance.getByteArray(null, null);
",0
"String key = null;
Object value = null;
ConfigurationNode node = new DefaultConfigurationNode();
key = String();
node.setName(key);
jj_consume_token(EQUAL);
value = Element();
node.setValue(value);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case DICT_SEPARATOR:
jj_consume_token(DICT_SEPARATOR);
break;
default:
jj_la1[1] = jj_gen;
;
}
{if (true) return node;}
",0
"List list = new ArrayList();
Object element = null;
jj_consume_token(ARRAY_BEGIN);
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_BEGIN:
case DICT_BEGIN:
case DATA:
case DATE:
case STRING:
case QUOTED_STRING:
element = Element();
list.add(element);
label_2:
while (true) {
switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
case ARRAY_SEPARATOR:
;
break;
default:
jj_la1[3] = jj_gen;
break label_2;
}
jj_consume_token(ARRAY_SEPARATOR);
element = Element();
list.add(element);
}
break;
default:
jj_la1[4] = jj_gen;
;
}
jj_consume_token(ARRAY_END);
{if (true) return list;}
",0
"jjmatchedPos = jjnewStateCnt = 0;
curLexState = defaultLexState;
input_stream = stream;
ReInitRounds();
}
",0
"jjround = 0x80000001;
for (i = 14; i-- > 0;)
{
jjrounds[i] = 0x80000000;
}
}
",0
public java.io.PrintStream debugStream = System.out;,0
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
",0
"ReInit(dstream, startline, startcolumn, 4096);
}
",0
"ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
}
",0
"if (bufpos >= tokenBegin)
return new String(buffer, tokenBegin, bufpos - tokenBegin + 1);
else
return new String(buffer, tokenBegin, bufsize - tokenBegin) +
",0
"catch (Exception e)
",0
"if (configuration.getURL() == null && configuration.getFileName() == null)
",0
"{
@Override
public void error(SAXParseException ex) throws SAXException
{
throw ex;
",0
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader().getResourceAsStream(""properties.dtd""));
",0
private AutoSaveListener autoSaveListener;,0
"return new Double(n.doubleValue());
",0
"catch (Exception e)
",0
"fs = ((CatalogManager) catalogManager).getFileSystem();
",0
"PrintStream stream = new PrintStream(os);
",0
"getLogger().debug(os.toString());
",0
"catch (Exception ex)
",0
"return dataSource;
",0
"catch (Exception e)
",0
"{
@Override
public InputSource resolveEntity(String publicId, String systemId)
{
return new InputSource(getClass().getClassLoader()
.getResourceAsStream(""PropertyList-1.0.dtd""));
",0
private final QueryResult<T> attributeResult;,0
"return this.userName;
",0
"return null;
",0
"return statement.execute(sql, autoGeneratedKeys);
",0
"statement.addBatch(sql);
",0
"return statement.executeLargeUpdate(sql, autoGeneratedKeys);
",0
"} catch (final Exception ie) {
",0
"stmt.execute(sql);
",0
"return value != null ? value.toCharArray() : null;
",0
"} catch (final Exception e) {
",0
"} catch (final Exception e) {
",0
"} catch (final Exception e) {
",0
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql, columnIndexes));
",0
"} catch (final Exception e) {
",0
"return this.connectionString;
",0
"return null;
",0
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency)));
",0
"return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, autoGeneratedKeys)));
",0
"return init(new DelegatingPreparedStatement(this, connection.prepareStatement(sql, columnIndexes)));
",0
"protected static final HashMap<String, ObjectPool<? extends Connection>> pools = new HashMap<>();",0
"return new DelegatingPreparedStatement(this, pooledConnection.prepareStatement(sql));
",0
"} catch (final Exception e) {
",0
"closeDueToException(info);
",0
"} catch (final Exception e) {
",0
"} catch (final Exception ignored) {
",0
"closeDueToException(info);
",0
"connection.prepareStatement(sql, resultSetType, resultSetConcurrency));
",0
"} catch (final Exception e) {
",0
"connection.prepareStatement(sql));
",0
"return statement.execute(sql);
",0
"stringBuilder.append(NUPROP_WARNTEXT.get(propertyName)).append("" You have set value of \"""")
",0
"return statement.executeLargeUpdate(sql, autoGeneratedKeys);
",0
"} catch (final Exception e) {
",0
"return statement.execute(sql, columnNames);
",0
private boolean closed;,0
"if ( paramTypes.length == 0 )
",0
"{
public Field[] run()
{
return type.getDeclaredFields();
",0
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0
"Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"",
",0
"Formatter formatter = new Formatter(""[CallMethodRule]"");
",0
"return ( null );
",0
"return ( null );
",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_FILENAME_ATTR = ""file"";",0
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
"} catch (Exception ex){
",0
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"return null;
",0
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0
"} catch (Exception e) {
",0
"this.annotations = annotations;
",0
"protected static Log log = LogFactory.getLog(""org.apache.commons.digester.Digester.sax"");",0
"public static String DFLT_FILENAME_ATTR = ""file"";",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"Formatter formatter = new Formatter(""[CallMethodRule]"");
",0
"log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
",0
protected String namespaceURI = null;,0
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
protected static String versionNumber = null;,0
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_FALSEVAL = ""false"";",0
protected String namespaceURI = null;,0
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
"public static String DFLT_FALSEVAL = ""false"";",0
private final List<ErrorMessage> errors;,0
"rulesBinder.addError( e );
",0
private final float loadFactor = 0.75f;,0
"private final Map<Class<?>, FromAnnotationsRuleSet> data = new LinkedHashMap<Class<?>, FromAnnotationsRuleSet>(capacity, loadFactor) {
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry(Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest) {
return size() > cacheSize;
}
};",0
"this.annotations = annotations;
",0
"version = new Float( versionNumber ).floatValue();
",0
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
protected static String versionNumber = null;,0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_FILENAME_ATTR = ""file"";",0
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
"public static String DFLT_FALSEVAL = ""false"";",0
private String currChildNamespaceURI = null;,0
private final int cacheSize = 255;,0
"protected static String JAXP_SCHEMA_LANGUAGE = ""http://java.sun.com/xml/jaxp/properties/schemaLanguage"";",0
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
"public static String DFLT_FALSEVAL = ""false"";",0
"return ( null );
",0
"return ( null );
",0
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
"public static String DFLT_PROPS_ATTR = ""setprops"";",0
"Object paramValues[] = new Object[this.paramTypes.length];
",0
"Formatter formatter = new Formatter().format(""CallMethodRule[methodName=%s, paramCount=%s, paramTypes={"",
",0
"private String matchPrefix = null;
private Rules decoratedRules = null;
private List<Rule> rules = new ArrayList<Rule>(1);
private AnyChildRule rule;
public AnyChildRules(AnyChildRule rule) {
this.rule = rule;
rules.add(rule);
}
public Digester getDigester() { return null; }
public void setDigester(Digester digester) {}
public String getNamespaceURI() { return null; }
public void setNamespaceURI(String namespaceURI) {}
public void add(String pattern, Rule rule) {}
public void clear() {}
public List<Rule> match(String namespaceURI, String matchPath) {
List<Rule> match = decoratedRules.match(namespaceURI, matchPath);
if ((matchPath.startsWith(matchPrefix))
&& (matchPath.indexOf('/', matchPrefix.length()) == -1)) {
if ((match == null || match.size()==0)) {
// just one rule: the one passed to this object's
return rules;
} else {
LinkedList<Rule> newMatch = new LinkedList<Rule>(match);
newMatch.addLast(rule);
return newMatch;
}
} else {
return match;
}
}
public List<Rule> rules() {
if (this.getDigester().getLog().isDebugEnabled()) {
this.getDigester().getLog().debug(""AnyChildRules.rules invoked."");
}
return decoratedRules.rules();
}
public void init(String prefix, Rules rules) {
matchPrefix = prefix;
decoratedRules = rules;
}
public Rules getOldRules() {
return decoratedRules;
",0
"Object paramValues[] = new Object[paramTypes.length];
",0
protected String namespaceURI = null;,0
private String currChildNamespaceURI = null;,0
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
"public static String DFLT_FILENAME_ATTR = ""file"";",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"public static String DFLT_PROPS_ATTR = ""setprops"";",0
protected String namespaceURI = null;,0
"protected static String XERCES_SCHEMA = ""http://apache.org/xml/features/validation/schema"";",0
"protected static String XERCES_DYNAMIC = ""http://apache.org/xml/features/validation/dynamic"";",0
"public static String DFLT_RESOURCE_SUFFIX = ""RuleInfo.xml"";",0
"public static String DFLT_FILENAME_ATTR = ""file"";",0
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0
"{
@Override
protected void loadRules()
{
loadXMLRules( xmlRulesResource );
}
",0
"this.updated = updated;
",0
"return s.toLowerCase();
",0
"final FileReader inRaw = new FileReader( source );
",0
"final FileWriter out = new FileWriter( dest );
",0
"final FileReader inRaw = new FileReader( source );
",0
"buf.replace( idx, idx + from.length(), to );
",0
"pw = new PrintWriter( stream );
",0
"return ( null );
",0
"return null;
",0
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0
"return memoryRulesBinder.forPattern( pattern );
",0
"this.updated = updated;
",0
"return new java.io.StringReader( baos.toString() );
",0
"addRules( d, connection );
",0
"if (paramTypes.length == 0) {
",0
"public final String DFLT_PLUGIN_CLASS_ATTR = ""plugin-class"";",0
"public static String DFLT_RESOURCE_ATTR = ""resource"";",0
"return ( null );
",0
"return ( null );
",0
"{
private static final long serialVersionUID = 1L;
@Override
protected boolean removeEldestEntry( Map.Entry<Class<?>, FromAnnotationsRuleSet> eldest )
{
return size() > cacheSize;
",0
"public static String DFLT_RULECLASS_SUFFIX = ""RuleInfo"";",0
"return memoryRulesBinder.forPattern( pattern );
",0
"return ( null );
",0
"rulesBinder.addError( e );
",0
"Object paramValues[] = new Object[paramTypes.length];
",0
"return new FactoryCreateRule( type, attributeName, ignoreCreateExceptions );
",0
"return ( null );
",0
"rulesBinder.addError( e );
",0
"return memoryRulesBinder.forPattern( pattern );
",0
"} catch (Exception e) {
",0
"} catch (Exception ex){
",0
"public static String DFLT_METHOD_ATTR = ""method"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_RULECLASS_ATTR = ""ruleclass"";",0
"public static String DFLT_METHOD_NAME = ""addRules"";",0
"public static String DFLT_PROPS_ATTR = ""setprops"";",0
"{
public Method[] run()
{
return type.getDeclaredMethods();
",0
"rulesBinder.addError( e );
",0
"{
public Field[] run()
{
return type.getDeclaredFields();
",0
"{
public Constructor<?>[] run()
{
return type.getDeclaredConstructors();
",0
"return memoryRulesBinder.forPattern( pattern );
",0
"Object[] paramValues = new Object[paramTypes.length];
",0
"if (keyPattern == null) {
return provider;
}
List<RuleProvider<? extends Rule>> providerLits = providers.get(keyPattern);
if (providerLits == null) {
providerLits = new ArrayList<RuleProvider<? extends Rule>>();
providers.put(keyPattern, providerLits);
}
providerLits.add(provider);
return provider;
",1
public final String DFLT_PLUGIN_ID_ATTR_NS = null;,0
private String namespaceURI;,1
"public static String DFLT_PROPS_ATTR = ""setprops"";",1
"public static String DFLT_METHOD_NAME = ""addRules"";",1
"public static String DFLT_FILENAME_ATTR = ""file"";",1
private boolean useContextClassLoader;,1
"log.debug("" Cannot resolve entity: '"" + entityURL + ""'"");
",1
"invokeExactMethod( parent, methodName, new Object[] { child }, paramTypes );
",0
private ClassLoader classLoader;,1
"public static String DFLT_METHOD_NAME = ""addRules"";",1
"throw new SAXException( format( ""[ObjectCreateRule]{%s} Class '%s' does not have a construcor with types"",
",0
"String charset = word.substring(2, charsetPos).toLowerCase();
",1
protected int lineCount = 0;,1
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
".trim().toLowerCase();
",0
"return new String(rawdata);
",0
"return cachedContent;
",1
"outputFile.delete();
",1
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
protected int lineLength;,1
"throw (FileUploadException) e.getCause();
",0
"return new String(rawdata);
",0
"return cachedContent;
",1
"&&  subContentType.toLowerCase()
",1
"return null;
",1
"fis.read(fileData);
",1
"this.chars = charArray;
",1
protected boolean lastCR = false;,1
"boundary = boundaryStr.getBytes(); 
",1
"String nameLower = name.toLowerCase();
",1
"byte[] rawdata = new byte[0];
",0
"return null;
",0
private boolean opened;,0
"&&  subContentType.toLowerCase()
",0
"this(null, null, null);
",0
"this.chars = chars;
",0
"outputFile.delete();
",0
"String nameLower = name.toLowerCase();
",0
"String nameLower = name.toLowerCase();
",0
"String nameLower = name.toLowerCase();
",0
"boundary = boundaryStr.getBytes();
",0
".trim().toLowerCase();
",0
"this.chars = chars;
",0
"fis.read(fileData);
",0
"return new String(rawdata);
",0
"String cdl = cd.toLowerCase();
",0
"this.chars = chars;
",0
"fis.read(fileData);
",0
"dfosFile.delete();
",0
"return new String(rawdata);
",0
"header += "" "" + headerPart.substring(nonWs, end);
",0
"throw (FileUploadException) e.getCause();
",0
".trim().toLowerCase();
",0
"protected static final byte[] FIELD_SEPARATOR = { CR, LF };",0
"skip(av);
",0
"private static final String UID =
new java.rmi.server.UID().toString()
.replace(':', '_').replace('-', '_');
private static int counter = 0;
private String fieldName;
private String contentType;
private boolean isFormField;
private String fileName;
private long size = -1;
private int sizeThreshold;
private File repository;
private byte[] cachedContent;
private transient DeferredFileOutputStream dfos;
private File dfosFile;
public DiskFileItem(String fieldName, String contentType,
boolean isFormField, String fileName, int sizeThreshold,
File repository) {
this.fieldName = fieldName;
this.contentType = contentType;
this.isFormField = isFormField;
this.fileName = fileName;
this.sizeThreshold = sizeThreshold;
this.repository = repository;
}
public InputStream getInputStream()
throws IOException {
if (!isInMemory()) {
return new FileInputStream(dfos.getFile());
}
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return new ByteArrayInputStream(cachedContent);
}
public String getContentType() {
return contentType;
}
public String getCharSet() {
ParameterParser parser = new ParameterParser();
parser.setLowerCaseNames(true);
Map params = parser.parse(getContentType(), ';');
return (String) params.get(""charset"");
}
public String getName() {
return fileName;
}
public boolean isInMemory() {
if (cachedContent != null) {
return true;
}
return dfos.isInMemory();
}
public long getSize() {
if (size >= 0) {
return size;
} else if (cachedContent != null) {
return cachedContent.length;
} else if (dfos.isInMemory()) {
return dfos.getData().length;
} else {
return dfos.getFile().length();
}
}
public byte[] get() {
if (isInMemory()) {
if (cachedContent == null) {
cachedContent = dfos.getData();
}
return cachedContent;
}
byte[] fileData = new byte[(int) getSize()];
FileInputStream fis = null;
try {
fis = new FileInputStream(dfos.getFile());
fis.read(fileData);
} catch (IOException e) {
fileData = null;
} finally {
if (fis != null) {
try {
fis.close();
} catch (IOException e) {
}
}
}
return fileData;
}
public String getString(final String charset)
throws UnsupportedEncodingException {
return new String(get(), charset);
}
public String getString() {
byte[] rawdata = get();
String charset = getCharSet();
if (charset == null) {
charset = DEFAULT_CHARSET;
}
try {
return new String(rawdata, charset);
} catch (UnsupportedEncodingException e) {
return new String(rawdata);
}
}
public void write(File file) throws Exception {
if (isInMemory()) {
FileOutputStream fout = null;
try {
fout = new FileOutputStream(file);
fout.write(get());
} finally {
if (fout != null) {
fout.close();
}
}
} else {
File outputFile = getStoreLocation();
if (outputFile != null) {
size = outputFile.length();
if (!outputFile.renameTo(file)) {
BufferedInputStream in = null;
BufferedOutputStream out = null;
try {
in = new BufferedInputStream(
new FileInputStream(outputFile));
out = new BufferedOutputStream(
new FileOutputStream(file));
IOUtils.copy(in, out);
} finally {
if (in != null) {
try {
in.close();
} catch (IOException e) {
}
}
if (out != null) {
try {
out.close();
} catch (IOException e) {
}
}
}
}
} else {
throw new FileUploadException(
""Cannot write uploaded file to disk!"");
}
}
}
public void delete() {
cachedContent = null;
File outputFile = getStoreLocation();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
public String getFieldName() {
return fieldName;
}
public void setFieldName(String fieldName) {
this.fieldName = fieldName;
}
public boolean isFormField() {
return isFormField;
}
public void setFormField(boolean state) {
isFormField = state;
}
public OutputStream getOutputStream()
throws IOException {
if (dfos == null) {
File outputFile = getTempFile();
dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);
}
return dfos;
}
public File getStoreLocation() {
return dfos.getFile();
}
protected void finalize() {
File outputFile = dfos.getFile();
if (outputFile != null && outputFile.exists()) {
outputFile.delete();
}
}
protected File getTempFile() {
File tempDir = repository;
if (tempDir == null) {
tempDir = new File(System.getProperty(""java.io.tmpdir""));
}
String tempFileName = ""upload_"" + UID + ""_"" + getUniqueId() + "".tmp"";
File f = new File(tempDir, tempFileName);
FileCleaner.track(f, this);
return f;
}
private static String getUniqueId() {
final int limit = 100000000;
int current;
synchronized (DiskFileItem.class) {
current = counter++;
}
String id = Integer.toString(current);
if (current < limit) {
id = (""00000000"" + id).substring(id.length());
}
return id;
}
public String toString() {
return ""name="" + this.getName()
+ "", StoreLocation=""
+ String.valueOf(this.getStoreLocation())
+ "", size=""
+ this.getSize()
+ ""bytes, ""
+ ""isFormField="" + isFormField()
+ "", FieldName=""
+ this.getFieldName();
}
private void writeObject(ObjectOutputStream out) throws IOException {
if (dfos.isInMemory()) {
cachedContent = get();
} else {
cachedContent = null;
dfosFile = dfos.getFile();
}
out.defaultWriteObject();
}
private void readObject(ObjectInputStream in)
throws IOException, ClassNotFoundException {
in.defaultReadObject();
OutputStream output = getOutputStream();
if (cachedContent != null) {
output.write(cachedContent);
} else {
FileInputStream input = new FileInputStream(dfosFile);
IOUtils.copy(input, output);
dfosFile.delete();
dfosFile = null;
}
output.close();
cachedContent = null;
}
",0
"fis.read(fileData);
",0
"throw (FileUploadException) e.getCause();
",0
"headerValue += "","" + iter2.next();
",0
"return (String) headers.get(name.toLowerCase());
",0
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
"headers = baos.toString();
",0
"skip(av);
",0
"dfosFile.delete();
",0
"&&  subContentType.toLowerCase()
",0
private boolean opened;,0
"boundary = boundaryStr.getBytes();
",0
"skip(av);
",0
"protected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };",0
"dfosFile.delete();
",0
"outputFile.delete();
",0
"String nameLower = name.toLowerCase();
",0
"boundary = boundaryStr.getBytes();
",0
"return (String) headers.get(name.toLowerCase());
",0
"headers = baos.toString();
",0
"skip(av);
",0
"paramName = paramName.toLowerCase();
",0
"this.fileItemFactory = (DefaultFileItemFactory) factory;
",0
"String cdl = pContentDisposition.toLowerCase();
",0
"headerValue += "","" + iter2.next();
",0
"skip(av);
",0
"headers = baos.toString();
",0
"this(null, null, null);
",0
"paramName = paramName.toLowerCase();
",0
"this.chars = chars;
",0
"return cachedContent;
",0
"return new String(rawdata);
",0
"dfosFile.delete();
",0
"end = parseEndOfLine(headerPart, nonWs);
",0
"while (iter2.hasNext()) {
",0
"if (contentType.toLowerCase().startsWith(MULTIPART)) {
",0
"av = makeAvailable();
",0
"return new String(rawdata);
",0
"IOUtils.copy(input, output);
",0
"}
",0
"header += "" "" + headerPart.substring(nonWs, end);
",0
"skip(av);
",0
"fis.read(fileData);
",0
"outputFile.delete();
",0
"return new String(rawdata);
",0
"String nameLower = name.toLowerCase();
",0
"return (String) headers.get(name.toLowerCase());
",0
"boundary = boundaryStr.getBytes();
",0
"return null;
",0
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
"dfosFile.delete();
",0
"outputFile.delete();
",0
"String nameLower = name.toLowerCase();
",0
"String nameLower = name.toLowerCase();
",0
"throw (FileUploadException) e.getCause();
",0
"return new String(rawdata);
",0
"outputFile.delete();
",0
"return parseRequest(new JakSrvltRequestContext(request));
",0
"throw (FileUploadException) e.getCause();
",0
"boundary = boundaryStr.getBytes();
",0
"return baos.toString();
",0
"throw (FileUploadException) e.getCause();
",0
"boundary = boundaryStr.getBytes(); 
",0
"protected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };",0
"this.chars = chars;
",0
"protected static final byte[] STREAM_TERMINATOR = { DASH, DASH };",0
"skip(av);
",0
"return cachedContent;
",0
"dfosFile.delete();
",0
"return baos.toString();
",0
"return null;
",0
"dfosFile.delete();
",0
"return new String(rawdata);
",0
"this.chars = charArray;
",0
"outputFile.delete();
",0
"String charset = word.substring(2, charsetPos).toLowerCase();
",0
protected List reactorProjects;,0
protected MavenProject project;,0
"MavenProject pomProject = mavenProjectBuilder.buildFromRepository( pomArtifact, this.remoteRepos, this.getLocal() );
",0
"DependencyManagement depMgt = project.getDependencyManagement();
",0
private MavenProject project;,0
private Renderer siteRenderer;,0
"out.getParentFile().mkdirs();
",0
private MavenProjectHelper projectHelper;,0
"else if ( arg1 == null )
",0
boolean outputFilterFile;,0
"installer.install( artifact.getFile(), baseArtifact, targetRepository );
",0
"ArtifactRepository targetRepository = repositoryFactory.createDeploymentArtifactRepository(
",0
"if ( parent.list().length < 2 )
",0
"outputWriter = new FileWriter( outputFile );
",0
"outputFile.getParentFile().mkdirs();
",0
"marker.createNewFile();
",0
protected List<MavenProject> reactorProjects;,0
protected MavenProject project;,0
private File cpFile;,0
private MavenProjectHelper projectHelper;,0
"installer.install( artifact.getFile(), artifact, targetRepository );
",0
"private Map<String, ArtifactRepositoryLayout> repositoryLayouts;",0
protected MavenProject project;,0
"if ( parent.list().length < 2 )
",0
"outputFile.getParentFile().mkdirs();
",0
"file.getParentFile().mkdirs();
",0
"marker.getParentFile().mkdirs();
",0
"marker.getParentFile().mkdirs();
",0
"unArchiver = archiverManager.getUnArchiver( file );
",0
public boolean silent;,0
protected List reactorProjects;,0
protected List reactorProjects;,0
"marker.getParentFile().mkdirs();
",0
"clearMarker.delete();
",0
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0
"DependencyManagement depMgt = project.getDependencyManagement();
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"return recommendedVersion.compareTo( theVersion ) <= 0;
",0
"clearMarker.delete();
",0
"location.mkdirs();
",0
"unArchiver = archiverManager.getUnArchiver( file );
",0
"if ( artifact != null )
",0
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0
"marker.getParentFile().mkdirs();
",0
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
"return this.fileMappers;
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"marker.createNewFile();
",0
"unArchiver = archiverManager.getUnArchiver( file );
",0
"location.mkdirs();
",0
"if ( artifact != null )
",0
"artifactItem.getOutputDirectory().mkdirs();
",0
"this.fileMappers = fileMappers;
",0
"return this.fileMappers;
",0
"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
",0
"dependency.setArtifact( dependency.getArtifact().setProperties( artifactProperties ) );
",0
"unArchiver = archiverManager.getUnArchiver( file );
",0
"artifactItem.getOutputDirectory().mkdirs();
",0
"this.fileMappers = fileMappers;
",0
"marker.getParentFile().mkdirs();
",0
protected MavenProjectBuilder mavenProjectBuilder;,0
private MavenProject project;,0
"public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator
{
private boolean stripVersion = false;
private String prefix;
private File cpFile;
private boolean regenerateFile;
public void execute()
throws MojoExecutionException
{
Set artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List artList = new ArrayList( artifacts );
StringBuffer sb = new StringBuffer();
Iterator i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( (Artifact) i.next(), sb );
while ( i.hasNext() )
{
sb.append(File.pathSeparatorChar);
appendArtifactPath( (Artifact) i.next(), sb );
}
}
String cpString = sb.toString();
if ( cpFile == null )
{
getLog().info( ""Dependencies classpath:\n"" + cpString );
}
else
{
if ( regenerateFile || !isUpdToDate( cpString ) )
{
storeClasspathFile( cpString );
}
else
{
this.getLog().info( ""Skipped writting classpath file '"" + cpFile + ""'.  No changes found."" );
}
}
}
protected void appendArtifactPath( Artifact art, StringBuffer sb )
{
if ( prefix == null )
{
sb.append( art.getFile() );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separatorChar );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion ) );
}
}
private boolean isUpdToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
}
catch ( Exception ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + cpFile + ""' for up-to-date check: "" + ex );
return false;
}
}
private void storeClasspathFile( String cpString )
throws MojoExecutionException
{
try
{
Writer w = new BufferedWriter( new FileWriter( cpFile ) );
try
{
w.write( cpString );
getLog().info( ""Written classpath file '"" + cpFile + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writting to classpath file '"" + cpFile + ""': ""
+ ex.toString(), ex );
}
finally
{
w.close();
}
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while opening/closing classpath file '"" + cpFile + ""': ""
+ ex.toString(), ex );
}
}
private String readClasspathFile()
throws IOException
{
if ( !cpFile.isFile() )
{
return null;
}
StringBuffer sb = new StringBuffer();
BufferedReader r = new BufferedReader( new FileReader( cpFile ) );
try
{
String l;
while ( ( l = r.readLine() ) != null )
{
sb.append( l );
}
return sb.toString();
}
finally
{
r.close();
}
}
public int compare( Object arg1, Object arg2 )
{
if ( arg1 instanceof Artifact && arg2 instanceof Artifact )
{
if ( arg1 == arg2 )
{
return 0;
}
else if ( arg1 == null )
{
return -1;
}
else if ( arg2 == null )
{
return +1;
}
Artifact art1 = (Artifact) arg1;
Artifact art2 = (Artifact) arg2;
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
else
{
return 0;
}
}
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
",0
"else if ( arg1 == null )
",0
private boolean excludeTransitive;,0
"marker.createNewFile();
",0
"clearMarker.delete();
",0
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
"@Parameter
protected boolean useJvmChmod = true;",0
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return Objects.equals( cpString, oldCp );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out,
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0
protected List reactorProjects;,0
protected List reactorProjects;,0
"if ( parent.list().length < 2 )
",0
"location.mkdirs();
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"return this.fileMappers;
",0
"this.fileMappers = fileMappers;
",0
"List<Artifact> artList = new ArrayList<>( artifacts );
",0
"return this.fileMappers;
",0
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0
"marker.getParentFile().mkdirs();
",0
protected List<MavenProject> reactorProjects;,0
"catch ( Exception e )
",0
protected boolean appendOutput;,0
"w = new BufferedWriter( new FileWriter( out ) );
",0
"installer.install( artifact.getFile(), baseArtifact, targetRepository );
",0
"installer.install( artifact.getFile(), artifact, targetRepository );
",0
protected ArtifactInstaller installer;,0
protected ArtifactRepositoryFactory repositoryFactory;,0
"project.getProperties().setProperty( artifact.getDependencyConflictId(),
",0
protected List<MavenProject> reactorProjects;,0
protected boolean outputScope;,0
"marker.getParentFile().mkdirs();
",0
"marker.createNewFile();
",0
"if ( !silent )
{
log.info( """" );
log.info( ""The following files have been resolved: "" );
if ( resolvedArtifacts.isEmpty() )
{
log.info( ""   none"" );
}
else
{
for ( Iterator i = resolvedArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
if ( existingArtifacts != null && !existingArtifacts.isEmpty() )
{
log.info( """" );
log.info( ""The following files where skipped: "" );
for ( Iterator i = existingArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
log.info( """" );
log.info( ""The following files have NOT been resolved: "" );
if ( missingArtifacts.isEmpty() )
{
log.info( ""   none"" );
}
else
{
for ( Iterator i = missingArtifacts.iterator(); i.hasNext(); )
{
log.info( ""   "" + ( (Artifact) i.next() ).getId() );
}
}
log.info( """" );
}
}
",0
"markersDirectory.mkdirs();
",0
"log.debug(""Artifacts:"");
Iterator iter = artifacts.iterator();
while (iter.hasNext())
{
Artifact artifact = (Artifact) iter.next();
log.debug(""""+artifact);
}
}
",0
"marker.createNewFile();
",0
"Set results = artifacts;
",0
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
"this.fileMappers = fileMappers;
",0
"this.fileMappers = fileMappers;
",0
"file.getParentFile().mkdirs();
",0
"marker.getParentFile().mkdirs();
",0
"catch ( Exception e )
",0
"this.fileMappers = fileMappers;
",0
"out.getParentFile().mkdirs();
",0
"file.getParentFile().mkdirs();
",0
"catch ( Exception e )
",0
"location.mkdirs();
",0
public boolean silent;,0
"DependencyManagement depMgt = project.getDependencyManagement();
",0
private MavenProject project;,0
boolean attach;,0
boolean outputFilterFile;,0
private boolean excludeTransitive;,0
"file.getParentFile().mkdirs();
",0
"unArchiver = archiverManager.getUnArchiver( file );
",0
"@Parameter(property = ""packaging"", defaultValue = ""jar"")
private String packaging = ""jar"";",0
"Set<Artifact> directDependencies = project.getDependencyArtifacts();
",0
"artifactItem.getOutputDirectory().mkdirs();
",0
"return this.fileMappers;
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"return ( cpString == oldCp || ( cpString != null && cpString.equals( oldCp ) ) );
",0
"List<Artifact> artList = new ArrayList<Artifact>( artifacts );
",0
"out.getParentFile().mkdirs();
",0
"outputWriter = new FileWriter( outputFile );
",0
"outputFile.getParentFile().mkdirs();
",0
"marker.getParentFile().mkdirs();
",0
"location.mkdirs();
",0
"if ( artifact != null )
",0
"artifactItem.getOutputDirectory().mkdirs();
",0
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"return this.fileMappers;
",0
"if ( plugins == null || plugins.isEmpty() )
",0
"List<org.apache.maven.model.Exclusion> exclusions = new ArrayList<>();
",0
"file.getParentFile().mkdirs();
",0
"marker.createNewFile();
",0
protected List reactorProjects;,0
"location.mkdirs();
",0
protected boolean outputAbsoluteArtifactFilename;,0
protected MavenProject project;,0
"UnArchiver unArchiver;
",0
"else
",0
private boolean excludeTransitive;,0
"marker.getParentFile().mkdirs();
",0
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0
"artifactItem.getOutputDirectory().mkdirs();
",0
"this.fileMappers = fileMappers;
",0
"return this.fileMappers;
",0
"this.fileMappers = fileMappers;
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"if ( results.getResolvedDependencies() == null || results.getResolvedDependencies().isEmpty() )
",0
"file.getParentFile().mkdirs();
",0
"return (cpString.equals(oldCp) || ( cpString != null && cpString.equals( oldCp ) ) );
",0
"w = new BufferedWriter( new FileWriter( out ) );
",0
"@Parameter
protected boolean useJvmChmod = true;",0
"@Parameter
protected boolean useJvmChmod = true;",0
"return recommendedVersion.compareTo( theVersion ) <= 0;
",0
"marker.createNewFile();
",0
"marker.getParentFile().mkdirs();
",0
"clearMarker.delete();
",0
"if (silent)
",0
private ArrayList artifactItems;,0
"location.mkdirs();
",0
"catch ( Exception e )
",0
"final PlexusContainer container = (PlexusContainer) context.get( PlexusConstants.PLEXUS_KEY );
",0
"List<Artifact> artList = new ArrayList<>( artifacts );
",0
"@Mojo( name = ""build-classpath"", requiresDependencyResolution = ResolutionScope.TEST, defaultPhase = LifecyclePhase.GENERATE_SOURCES, threadSafe = true )
// CHECKSTYLE_ON: LineLength
public class BuildClasspathMojo
extends AbstractDependencyFilterMojo
implements Comparator<Artifact>
{
@Parameter( property = ""outputEncoding"", defaultValue = ""${project.reporting.outputEncoding}"" )
private String outputEncoding;
@Parameter( property = ""mdep.stripVersion"", defaultValue = ""false"" )
private boolean stripVersion = false;
@Parameter( property = ""mdep.stripClassifier"", defaultValue = ""false"" )
private boolean stripClassifier = false;
@Parameter( property = ""mdep.prefix"" )
private String prefix;
@Parameter( property = ""mdep.outputProperty"" )
private String outputProperty;
@Parameter( property = ""mdep.outputFile"" )
private File outputFile;
@Parameter( property = ""mdep.regenerateFile"", defaultValue = ""false"" )
private boolean regenerateFile;
@Parameter( property = ""mdep.fileSeparator"", defaultValue = """" )
private String fileSeparator;
@Parameter( property = ""mdep.pathSeparator"", defaultValue = """" )
private String pathSeparator;
@Parameter( property = ""mdep.localRepoProperty"", defaultValue = """" )
private String localRepoProperty;
@Parameter( defaultValue = ""false"" )
private boolean attach;
@Parameter( property = ""mdep.outputFilterFile"", defaultValue = ""false"" )
private boolean outputFilterFile;
@Parameter( property = ""mdep.useBaseVersion"", defaultValue = ""true"" )
private boolean useBaseVersion = true;
@Component
private MavenProjectHelper projectHelper;
@Component
private RepositoryManager repositoryManager;
@Override
protected void doExecute()
throws MojoExecutionException
{
boolean isFileSepSet = StringUtils.isNotEmpty( fileSeparator );
boolean isPathSepSet = StringUtils.isNotEmpty( pathSeparator );
if ( attach && StringUtils.isEmpty( localRepoProperty ) )
{
localRepoProperty = ""${M2_REPO}"";
}
Set<Artifact> artifacts = getResolvedDependencies( true );
if ( artifacts == null || artifacts.isEmpty() )
{
getLog().info( ""No dependencies found."" );
}
List<Artifact> artList = new ArrayList<>( artifacts );
StringBuilder sb = new StringBuilder();
Iterator<Artifact> i = artList.iterator();
if ( i.hasNext() )
{
appendArtifactPath( i.next(), sb );
while ( i.hasNext() )
{
sb.append( isPathSepSet ? this.pathSeparator : File.pathSeparator );
appendArtifactPath( i.next(), sb );
}
}
String cpString = sb.toString();
if ( isFileSepSet )
{
final String pattern = Pattern.quote( File.separator );
final String replacement = Matcher.quoteReplacement( fileSeparator );
cpString = cpString.replaceAll( pattern, replacement );
}
if ( outputFilterFile )
{
cpString = ""classpath="" + cpString;
}
if ( outputProperty != null )
{
getProject().getProperties().setProperty( outputProperty, cpString );
if ( getLog().isDebugEnabled() )
{
getLog().debug( outputProperty + "" = "" + cpString );
}
}
if ( outputFile == null )
{
getLog().info( ""Dependencies classpath:"" + System.lineSeparator() + cpString );
}
else
{
if ( regenerateFile || !isUpToDate( cpString ) )
{
storeClasspathFile( cpString, outputFile );
}
else
{
this.getLog().info( ""Skipped writing classpath file '"" + outputFile + ""'.  No changes found."" );
}
}
if ( attach )
{
attachFile( cpString );
}
}
protected void attachFile( String cpString )
throws MojoExecutionException
{
File attachedFile = new File( getProject().getBuild().getDirectory(), ""classpath"" );
storeClasspathFile( cpString, attachedFile );
projectHelper.attachArtifact( getProject(), attachedFile, ""classpath"" );
}
protected void appendArtifactPath( Artifact art, StringBuilder sb )
{
if ( prefix == null )
{
String file = art.getFile().getPath();
if ( StringUtils.isNotEmpty( localRepoProperty ) )
{
ProjectBuildingRequest projectBuildingRequest = session.getProjectBuildingRequest();
File localBasedir = repositoryManager.getLocalRepositoryBasedir( projectBuildingRequest );
file = StringUtils.replace( file, localBasedir.getAbsolutePath(), localRepoProperty );
}
sb.append( file );
}
else
{
// TODO: add param for prepending groupId and version.
sb.append( prefix );
sb.append( File.separator );
sb.append( DependencyUtil.getFormattedFileName( art, this.stripVersion, this.prependGroupId,
this.useBaseVersion, this.stripClassifier ) );
}
}
private boolean isUpToDate( String cpString )
{
try
{
String oldCp = readClasspathFile();
return ( cpString == null ? oldCp == null : cpString.equals( oldCp ) );
}
catch ( IOException ex )
{
this.getLog().warn( ""Error while reading old classpath file '"" + outputFile + ""' for up-to-date check: ""
+ ex );
return false;
}
}
private void storeClasspathFile( String cpString, File out )
throws MojoExecutionException
{
out.getParentFile().mkdirs();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( Writer w =
new BufferedWriter( new OutputStreamWriter( new FileOutputStream( out ), encoding ) ) )
{
w.write( cpString );
getLog().info( ""Wrote classpath file '"" + out + ""'."" );
}
catch ( IOException ex )
{
throw new MojoExecutionException( ""Error while writing to classpath file '"" + out + ""': "" + ex.toString(),
ex );
}
}
protected String readClasspathFile()
throws IOException
{
if ( outputFile == null )
{
throw new IllegalArgumentException( ""The outputFile parameter ""
+ ""cannot be null if the file is intended to be read."" );
}
if ( !outputFile.isFile() )
{
return null;
}
StringBuilder sb = new StringBuilder();
String encoding = Objects.toString( outputEncoding, ""UTF-8"" );
try ( BufferedReader r =
new BufferedReader( new InputStreamReader( new FileInputStream( outputFile ), encoding ) ) )
{
for ( String line = r.readLine(); line != null; line = r.readLine() )
{
sb.append( line );
}
return sb.toString();
}
}
@Override
public int compare( Artifact art1, Artifact art2 )
{
if ( art1 == art2 )
{
return 0;
}
else if ( art1 == null )
{
return -1;
}
else if ( art2 == null )
{
return +1;
}
String s1 = art1.getGroupId() + art1.getArtifactId() + art1.getVersion();
String s2 = art2.getGroupId() + art2.getArtifactId() + art2.getVersion();
return s1.compareTo( s2 );
}
@Override
protected ArtifactsFilter getMarkedArtifactFilter()
{
return null;
}
public void setOutputFile( File outputFile )
{
this.outputFile = outputFile;
}
public void setOutputProperty( String theOutputProperty )
{
this.outputProperty = theOutputProperty;
}
public void setFileSeparator( String theFileSeparator )
{
this.fileSeparator = theFileSeparator;
}
public void setPathSeparator( String thePathSeparator )
{
this.pathSeparator = thePathSeparator;
}
public void setPrefix( String thePrefix )
{
this.prefix = thePrefix;
}
public void setRegenerateFile( boolean theRegenerateFile )
{
this.regenerateFile = theRegenerateFile;
}
public boolean isStripVersion()
{
return this.stripVersion;
}
public void setStripVersion( boolean theStripVersion )
{
this.stripVersion = theStripVersion;
}
public void setLocalRepoProperty( String localRepoProperty )
{
this.localRepoProperty = localRepoProperty;
}
",0
"Set<Artifact> resolvedArtifacts = new LinkedHashSet<>( artifacts.size() );
",0
"marker.createNewFile();
",0
"+ ( this.outputAbsoluteArtifactFilename ? file.getAbsolutePath() : file.getName() ) + "" to: ""
",0
"@Parameter(property = ""mdep.prependGroupId"", defaultValue = ""false"")
private final boolean prependGroupId = false;",0
"r = new BufferedReader( new FileReader( outputFile ) );
",1
"else if ( arg2 == null )
",1
private MavenProject project;,0
private MavenProject project;,1
"BufferedReader r = new BufferedReader( new FileReader( outputFile ) );
",0
private ArtifactFactory factory;,0
"model = pomReader.read( new FileReader( project.getFile() ) );
",1
private boolean excludeTransitive;,1
"final Properties fp = new Properties();
final InputStream ras = Main.class.getResourceAsStream(""examples.properties"");
if (ras != null) {
fp.load(ras);
} else {
System.err.println(""[Cannot find examples.properties file, so aliases cannot be used]"");
}
if (args.length == 0) {
if (Thread.currentThread().getStackTrace().length > 2) { 
System.out.println(""Usage: mvn -q exec:java  -Dexec.arguments=<alias or"" +
"" exampleClass>,<exampleClass parameters> (comma-separated, no spaces)"");
System.out.println(""Or   : mvn -q exec:java  -Dexec.args=\""<alias"" +
"" or exampleClass> <exampleClass parameters>\"" (space separated)"");
} else {
if (fromJar()) {
System.out.println(
""Usage: java -jar commons-net-examples-m.n.jar <alias or exampleClass> <exampleClass parameters>"");
} else {
System.out.println(
""Usage: java -cp target/classes examples/Main <alias or exampleClass> <exampleClass parameters>"");
}
}
@SuppressWarnings(""unchecked"") 
List<String> l = (List<String>) Collections.list(fp.propertyNames());
if (l.isEmpty()) {
return;
}
Collections.sort(l);
System.out.println(""\nAliases and their classes:"");
for(String s : l) {
System.out.printf(""%-25s %s%n"",s,fp.getProperty(s));
}
return;
}
String shortName = args[0];
String fullName = fp.getProperty(shortName);
if (fullName == null) {
fullName = shortName;
}
fullName = fullName.replace('/', '.');
try {
Class<?> clazz = Class.forName(fullName);
Method m = clazz.getDeclaredMethod(""main"", new Class[]{args.getClass()});
String[] args2 = new String[args.length-1];
System.arraycopy(args, 1, args2, 0, args2.length);
try {
m.invoke(null, (Object)args2);
} catch (InvocationTargetException ite) {
Throwable cause = ite.getCause();
if (cause != null) {
throw cause;
} else {
throw ite;
}
}
} catch (ClassNotFoundException e) {
System.out.println(e);
}
}
",0
"this(new PrintWriter(stream), suppressLogin);
",0
"this(new PrintWriter(stream), suppressLogin, eolMarker, showDirection);
",0
"createCommandSupport();
",0
"return null;
",0
"ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0
public int size;,0
"return null;
",0
"return null;
",0
"__queue.wait(100);
",0
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0
"modulus = (++modulus) % 4;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
"file.setUser(usr);
",0
"return (IOException) getCause(); 
",0
"return null;
",0
"return null;
",0
"return null;
",0
"num = size = 0;
",0
public String identifier;,0
"aytMonitor.wait(timeout);
",0
"__queue.notify();
",0
"__queue.notify();
",0
"__receiveState = _STATE_DATA;
break; 
",0
private final CopyOnWriteArrayList<EventListener> __listeners;,0
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0
"(SSLSocket) ssf.createSocket(_socket_, host, port, false);
",0
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0
"return (IOException) getCause(); 
",0
"return null;
",0
"pointer.articleId = tokens[i++];
",0
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
bogusIdCount++ ; 
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0
"num = size = 0;
",0
"aytMonitor.wait(timeout);
",0
"__queue.notify();
",0
"return null;
",0
"modulus = (++modulus) % 4;
",0
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0
"this(new PrintWriter(stream), suppressLogin);
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"file = unixFTPEntryParser.parseFTPEntry(entry);
",0
"return null;
",0
"return null;
",0
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
bogusIdCount++ ; 
id = ""<Bogus-id:"" + (bogusIdCount) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0
"computeDetails();
",0
"return null;
",0
"__queue.notify();
",0
"__queue.notify();
",0
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0
"modulus = (++modulus) % 3;
",0
private final CopyOnWriteArrayList<EventListener> __listeners;,0
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0
"return new String(receivePacket.getData(), 0, receivePacket.getLength());
",0
"new BufferedReader(new InputStreamReader(getInputStream(longOutput,
",0
"return null;
",0
"return null;
",0
"if (messages == null) {
return null;
}
idTable = new HashMap<String,ThreadContainer>();
for (Threadable t : messages) {
if (!t.isDummy()) {
buildContainer(t);
}
}
root = findRootSet();
idTable.clear();
idTable = null;
pruneEmptyContainers(root);
root.reverseChildren();
gatherSubjects();
if (root.next != null) {
throw new RuntimeException(""root node has a next:"" + root);
}
for (ThreadContainer r = root.child; r != null; r = r.next) {
if (r.threadable == null) {
r.threadable = r.child.threadable.makeDummy();
}
}
Threadable result = (root.child == null ? null : root.child.threadable);
root.flush();
root = null;
return result;
",0
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0
"return null;
",0
"__queue.wait(100);
",0
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0
"modulus = (++modulus) % 4;
",0
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0
"this(new PrintWriter(stream));
",0
"createCommandSupport();
",0
"return null;
",0
"String str = null;
try {
str = new String(encode, ""UTF8"");
} catch (UnsupportedEncodingException ue) {
throw new RuntimeException(ue);
}
return str;
",0
"return pArray.getBytes(""UTF8"");
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
",0
private final CopyOnWriteArrayList<EventListener> __listeners;,0
"long countLong = getAddressCountLong();
if (countLong > Integer.MAX_VALUE) {
throw new RuntimeException(""Count is larger than an integer: "" + countLong);
}
return (int)countLong;
",0
"this(new PrintWriter(stream));
",0
"return null;
",0
"return null;
",0
"@Deprecated
public static String STORE_TYPE;",0
"return null;
",0
"createCommandSupport();
",0
"pointer.articleId = tokens[i++];
",0
"return null;
",0
"ThreadContainer root = new ThreadContainer();
Iterator<String> iter = idTable.keySet().iterator();
while (iter.hasNext()) {
Object key = iter.next();
ThreadContainer c = idTable.get(key);
if (c.parent == null) {
if (c.next != null) {
throw new RuntimeException(
""c.next is "" + c.next.toString());
}
c.next = root.child;
root.child = c;
}
}
return root;
",0
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
int bogusIdCount = 0;
if (container != null) {
if (container.threadable != null) { 
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (String refString : references)
{
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0
"return null;
",0
"return null;
",0
"__receiveState = _STATE_DATA;
break; 
",0
"return null;
",0
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0
"System.arraycopy(_filename.getBytes(), 0, data, 2, fileLength);
",0
"this(new PrintWriter(stream), suppressLogin, eolMarker);
",0
"return null;
",0
"@Deprecated
public static String TRUSTSTORE_ALGORITHM;",0
"file.setGroup(grp);
",0
"file.setUser(usr);
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"return null;
",0
"dataLength = lastBlock = hostPort = bytesRead = totalThisPacket = 0;
",0
"modulus = (++modulus) % 4;
",0
"_output_.write(username.getBytes());
",0
"return null;
",0
"return sendCommand(CMD_ENC, new String(Base64.encodeBase64(data)));
",0
"@Deprecated
public static String KEYSTORE_ALGORITHM;",0
"pointer.articleId = tokens[i++];
",0
"if (parent != null && threadable == null) {
throw new RuntimeException(""no threadable in "" + this.toString());
}
parent = null;
if (threadable != null) {
threadable.setChild(child == null ? null : child.threadable);
}
if (child != null) {
child.flush();
child = null;
}
if (threadable != null) {
threadable.setNext(next == null ? null : next.threadable);
}
if (next != null) {
next.flush();
next = null;
}
threadable = null;
}
",0
"String id = threadable.messageThreadId();
ThreadContainer container = idTable.get(id);
if (container != null) {
if (container.threadable != null) { 
id = ""<Bogus-id:"" + (bogusIdCount++) + "">"";
container = null;
} else {
container.threadable = threadable;
}
}
if (container == null) {
container = new ThreadContainer();
container.threadable = threadable;
idTable.put(id, container);
}
ThreadContainer parentRef = null;
{
String[] references = threadable.messageThreadReferences();
for (int i = 0; i < references.length; ++i) {
String refString = references[i];
ThreadContainer ref = idTable.get(refString);
if (ref == null) {
ref = new ThreadContainer();
idTable.put(refString, ref);
}
// Link references together in the order they appear in the References: header,
if ((parentRef != null)
&& (ref.parent == null)
&& (parentRef != ref)
&& !(ref.findChild(parentRef))) {
ref.parent = parentRef;
ref.next = parentRef.child;
parentRef.child = ref;
}
parentRef = ref;
}
}
if (parentRef != null
&& (parentRef == container || container.findChild(parentRef)))
{
parentRef = null;
}
// if it has a parent already, its because we saw this message in a References: field, and presumed
if (container.parent != null) {
ThreadContainer rest, prev;
for (prev = null, rest = container.parent.child;
rest != null;
prev = rest, rest = rest.next) {
if (rest == container) {
break;
}
}
if (rest == null) {
throw new RuntimeException(
""Didnt find ""
+ container
+ "" in parent""
+ container.parent);
}
if (prev == null) {
container.parent.child = container.next;
} else {
prev.next = container.next;
}
container.next = null;
container.parent = null;
}
if (parentRef != null) {
container.parent = parentRef;
container.next = parentRef.child;
parentRef.child = container;
}
}
",0
"computeDetails();
",0
"num = size = 0;
",0
"(SSLSocket) ssf.createSocket(_socket_, ip, port, true);
",0
"return null;
",0
"return null;
",0
"aytMonitor.wait(timeout);
",0
"__queue.notify();
",0
"__queue.notify();
",0
"__receiveState = _STATE_DATA;
break; 
",0
"return null;
",0
"System.arraycopy(_message.getBytes(), 0, data, 4, length);
",0
"if (!(pObject instanceof byte[])) {
throw new RuntimeException(""Parameter supplied to Base64 encode is not a byte[]"");
}
return encode((byte[]) pObject);
",0
"switch (modulus) {
case 2 :
x = x << 6;
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
break;
case 3 :
buffer[pos++] = (byte) ((x >> 16) & MASK_8BITS);
buffer[pos++] = (byte) ((x >> 8) & MASK_8BITS);
",0
"modulus = (++modulus) % 3;
",0
"public FTPHTTPClient(String proxyHost, int proxyPort, String proxyUser, String proxyPass) {
this.proxyHost = proxyHost;
this.proxyPort = proxyPort;
this.proxyUsername = proxyUser;
this.proxyPassword = proxyPass;
try {
CRLF = ""\r\n"".getBytes(getControlEncoding());
} catch (UnsupportedEncodingException e) {
throw new RuntimeException(e);
}
}
",1
"return null;
",0
"for (ThreadContainer c = root.child; c != null; c = c.next)
",1
"file.setGroup(grp);
",0
"aytMonitor.wait(timeout);
",0
"(SSLSocket) ssf.createSocket(_socket_, ip, port, false);
",0
"(SSLSocket) ssf.createSocket(_socket_, ip, port, true);
",0
"output = new ToNetASCIIOutputStream(getBufferedOutputStream(socket.getOutputStream()));
",0
"Base64.encodeBase64((""\000"" + username + ""\000"" + password).getBytes())
",0
"this.rootCause = rootCause;
",1
"file.setGroup(grp);
",0
"} catch (Exception e) {
",0
"scheduledFuture.cancel(false);
",0
private GenericObjectPoolConfig config;,0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"ObjectQueue pool = _poolMap.get(key);
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e1) {
",0
"} catch (Exception e2) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
private long _maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;,0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
private int maxSleeping;,0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"if (objectDeque != null) {
",0
"} catch (Exception e) {
",0
"} catch (final Exception e1) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e1) {
",0
"} catch (Exception e2) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"ObjectQueue pool = _poolMap.get(key);
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"} catch (Exception e2) {
",0
"latch.notify();
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"ObjectQueue pool = _poolMap.get(key);
",0
"} catch (Exception e) {
",0
"final CursorableLinkedList<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
",0
"writeLock.tryLock();
",0
"readLock.tryLock();
",0
"} catch (Exception e) {
",0
"if (!underTest.endEvictionTest()) {
",0
"writeLock.tryLock();
",0
"poolMap.get(k).getIdleObjects();
",0
"} catch (Exception e) {
",0
private int initIdleCapacity;,0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"_activeCount.put(key,new Integer(1));
",1
"final ObjectDeque<T> deque = poolMap.get(k);
",1
"writeLock.tryLock();
",1
"} catch (Exception e) {
",1
private PoolableObjectFactory _factory = null;,1
"if (p == null && objectDeque != null) {
",1
private boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;,1
"} catch (Exception e) {
",1
private int maxSleeping;,1
"if (objectDeque != null) {
",1
"} catch (Exception e2) {
",1
"readLock.tryLock();
",1
"Collection c = (Collection) m.get(key);
",1
protected int _totIdle = 0;,1
"} catch(Exception e) {
",1
"writeLock.tryLock();
",1
"poolMap.get(k).getIdleObjects();
",1
"} catch (Exception e) {
",1
"final ObjectDeque<T> deque = poolMap.get(k);
",1
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
"_activeCount.put(key,new Integer(1));
",1
"readLock.tryLock();
",1
private boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;,1
"result = result * ((counter - 1) / counter) +
",1
"readLock.tryLock();
",1
"} catch (Exception e) {
",1
"writeLock.tryLock();
",1
"return ((IdentityWrapper) other).instance == instance;
",1
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;,1
"ObjectDeque<T> queue = poolMap.get(key);
",1
private int maxSleeping;,1
private int initIdleCapacity;,1
"ObjectDeque<T> queue = poolMap.get(key);
",1
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"final ObjectDeque<T> deque = poolMap.get(k);
",0
"} catch (Exception e1) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"Stack<V> s = _pools.get(key);
",0
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this(null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this(null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap<K, Stack<V>>();
_activeCount = new HashMap<K, Integer>();
}
@Override
public synchronized V borrowObject(K key) throws Exception {
assertOpen();
Stack<V> stack = (_pools.get(key));
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
V obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
@Override
public synchronized void returnObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
@Override
public synchronized void invalidateObject(K key, V obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
@Override
public synchronized void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack<V> stack = _pools.get(key);
if(null == stack) {
stack = new Stack<V>();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final V staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
@Override
public synchronized int getNumIdle() {
return _totIdle;
}
@Override
public synchronized int getNumActive() {
return _totActive;
}
@Override
public synchronized int getNumActive(K key) {
return getActiveCount(key);
}
@Override
public synchronized int getNumIdle(K key) {
try {
return(_pools.get(key)).size();
} catch(Exception e) {
return 0;
}
}
@Override
public synchronized void clear() {
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
Stack<V> stack = _pools.get(key);
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
@Override
public synchronized void clear(K key) {
Stack<V> stack = _pools.remove(key);
destroyStack(key,stack);
}
private synchronized void destroyStack(K key, Stack<V> stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator<V> it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
@Override
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator<K> it = _pools.keySet().iterator();
while(it.hasNext()) {
K key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack<V> s = _pools.get(key);
buf.append(s.size());
}
return buf.toString();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Deprecated
@Override
public synchronized void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized KeyedPoolableObjectFactory<K, V> getFactory() {
return _factory;
}
private int getActiveCount(K key) {
try {
return _activeCount.get(key).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(K key) {
_totActive++;
Integer old = _activeCount.get(key);
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(K key) {
_totActive--;
Integer active = _activeCount.get(key);
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
public Map<K, Stack<V>> getPools() {
return _pools;
}
public int getMaxSleeping() {
return _maxSleeping;
}
public int getInitSleepingCapacity() {
return _initSleepingCapacity;
}
public int getTotActive() {
return _totActive;
}
public int getTotIdle() {
return _totIdle;
}
public Map<K, Integer> getActiveCount() {
return _activeCount;
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected HashMap<K, Stack<V>> _pools = null;
@Deprecated
protected KeyedPoolableObjectFactory<K, V> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
@Deprecated
protected int _totActive = 0;
@Deprecated
protected int _totIdle = 0;
@Deprecated
",0
"Stack<V> stack = _pools.get(key);
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception ex2) {
",0
"catch (Exception e) {
",0
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0
"latch.notify();
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"private Listable _prev = null;
private Listable _next = null;
private Object _val = null;
Listable(Listable prev, Listable next, Object val) {
_prev = prev;
_next = next;
_val = val;
}
Listable next() {
return _next;
}
Listable prev() {
return _prev;
}
Object value() {
return _val;
}
void setNext(Listable next) {
_next = next;
}
void setPrev(Listable prev) {
_prev = prev;
}
Object setValue(Object val) {
Object temp = _val;
_val = val;
return temp;
",0
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0
"l.notify();
",0
"} catch (Exception ex2) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
protected int _totIdle = 0;,0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0
"latch.notify();
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"Stack s = (Stack)(_pools.get(key));
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"latch.notify();
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"@Deprecated
protected int _totIdle = 0;",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"Stack stack = (Stack)(_pools.get(key));
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"catch (Exception e) {
",0
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0
"Stack s = (Stack)(_pools.get(key));
",0
"} catch (Exception e2) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0
"} catch (Exception ex2) {
",0
"} catch(Exception e) {
",0
"} catch (Exception ex2) {
",0
"Stack stack = (Stack)(_pools.get(key));
",0
"} catch (Exception e2) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"catch (Exception e) {
",0
"public class GenericKeyedObjectPool<K, V> extends BaseKeyedObjectPool<K, V> implements KeyedObjectPool<K, V> {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory<K, V> factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap<K, ObjectQueue>();
_poolList = new CursorableLinkedList<K>();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public void setMaxTotal(int maxTotal) {
synchronized(this) {
_maxTotal = maxTotal;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
int maxIdle = getMaxIdle();
if (_minIdle > maxIdle) {
return maxIdle;
} else {
return _minIdle;
}
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
@Override
public V borrowObject(K key) throws Exception {
long starttime = System.currentTimeMillis();
Latch<K, V> latch = new Latch<K, V>(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
latch.getPool().decrementInternalProcessingCount();
doAllocate = true;
} else {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
returnObject(latch.getkey(), latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
V obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair<V>(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
}
allocate();
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) {
return;
}
Iterator<Latch<K, V>> allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch<K, V> latch = allocationQueueIter.next();
ObjectQueue pool = (_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
@Override
public void clear() {
Map<K,  List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K,  List<ObjectTimestampPair<V>>>();
synchronized (this) {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final Map<ObjectTimestampPair<V>, K> map = new TreeMap<ObjectTimestampPair<V>, K>();
synchronized (this) {
for (Iterator<K> keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final K key = keyiter.next();
final List<ObjectTimestampPair<V>> list = _poolMap.get(key).queue;
for (Iterator<ObjectTimestampPair<V>> it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set<Entry<ObjectTimestampPair<V>, K>> setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator<Entry<ObjectTimestampPair<V>, K>> iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Entry<ObjectTimestampPair<V>, K> entry = iter.next();
K key = entry.getValue();
ObjectTimestampPair<V> pairTimeStamp = entry.getKey();
ObjectQueue objectQueue = _poolMap.get(key);
final List<ObjectTimestampPair<V>> list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
toDestroy.get(key).add(pairTimeStamp);
} else {
List<ObjectTimestampPair<V>> listForKey = new ArrayList<ObjectTimestampPair<V>>();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
@Override
public void clear(K key) {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K , List<ObjectTimestampPair<V>>>();
final ObjectQueue pool;
synchronized (this) {
pool = _poolMap.remove(key);
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map<K,  List<ObjectTimestampPair<V>>> m, KeyedPoolableObjectFactory<K, V> factory) {
for (Iterator<Entry<K,  List<ObjectTimestampPair<V>>>> entries = m.entrySet().iterator(); entries.hasNext();) {
Entry<K,  List<ObjectTimestampPair<V>>> entry = entries.next();
K key = entry.getKey();
List<ObjectTimestampPair<V>> c = entry.getValue();
for (Iterator<ObjectTimestampPair<V>> it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,it.next().value);
} catch(Exception e) {
} finally {
synchronized(this) {
ObjectQueue objectQueue =
_poolMap.get(key);
if (objectQueue != null) {
objectQueue.decrementInternalProcessingCount();
if (objectQueue.internalProcessingCount == 0 &&
objectQueue.activeCount == 0 &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_totalInternalProcessing--;
}
}
allocate();
}
}
}
}
@Override
public synchronized int getNumActive() {
return _totalActive;
}
@Override
public synchronized int getNumIdle() {
return _totalIdle;
}
@Override
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
@Override
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
@Override
public void returnObject(K key, V obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}
private void addObjectToPool(K key, V obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = _poolMap.get(key);
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair<V>(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair<V>(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
@Override
public void invalidateObject(K key, V obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
}
allocate(); 
}
}
@Override
public void addObject(K key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
V obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(K key, boolean populateImmediately) {
ObjectQueue pool = (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
@Override
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch<K, V> l = _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
@Deprecated
@Override
public void setFactory(KeyedPoolableObjectFactory<K, V> factory) throws IllegalStateException {
Map<K, List<ObjectTimestampPair<V>>> toDestroy = new HashMap<K, List<ObjectTimestampPair<V>>>();
final KeyedPoolableObjectFactory<K, V> oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator<K> it = _poolMap.keySet().iterator(); it.hasNext();) {
K key = it.next();
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
List<ObjectTimestampPair<V>> objects = new ArrayList<ObjectTimestampPair<V>>();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
K key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair<V> pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
_evictionCursor.previous() :
_evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue =
_poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() &&
objectQueue.activeCount == 0 &&
objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = _poolMap.get(key);
if (pool != null) {
CursorableLinkedList<ObjectTimestampPair<V>> queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
@SuppressWarnings(""unchecked"")
private void ensureMinIdle() throws Exception {
if (getMinIdle() > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle((K)keysCopy[i]);
}
}
}
private void ensureMinIdle(K key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
}
allocate();
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator<K> it = _poolMap.keySet().iterator();
while (it.hasNext()) {
K key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList<ObjectTimestampPair<V>> queue = new CursorableLinkedList<ObjectTimestampPair<V>>();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair<T> implements Comparable<T> {
private final T value;
private final long tstamp;
ObjectTimestampPair(T val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(T val, long time) {
value = val;
tstamp = time;
}
@Override
public String toString() {
return value + "";"" + tstamp;
}
@SuppressWarnings(""unchecked"")
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair<T>) obj);
}
public int compareTo(ObjectTimestampPair<T> other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public T getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
@Override
public void run() {
ClassLoader savedClassLoader =
Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(
_factoryClassLoader);
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private final class Latch<LK, LV> {
private final LK _key;
private ObjectQueue _pool;
private ObjectTimestampPair<LV> _pair;
private boolean _mayCreate = false;
private Latch(LK key) {
_key = key;
}
private synchronized LK getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair<LV> getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair<LV> pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictabl",0
"l.notify();
",0
"latch.notify();
",0
"} catch(Exception e) {
",0
"@Deprecated
protected int _totIdle = 0;",0
"} catch (Exception e2) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"latch.notify();
",0
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0
"latch.notify();
",0
protected int _totIdle = 0;,0
"} catch (Exception e) {
",0
"} catch (Exception ex2) {
",0
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.minIdle,
config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle,
config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory, maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_MIN_IDLE, testOnBorrow,
testOnReturn, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait,
int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle,
long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
allocate();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
allocate();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch();
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if(latch.getPair() == null) {
if(latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
_numInternalProcessing++;
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null) {
if(maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized(this) {
if (latch.getPair() == null) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if(null == latch.getPair()) {
try {
Object obj = _factory.makeObject();
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
try {
_factory.activateObject(latch.getPair().value);
if(_testOnBorrow &&
!_factory.validateObject(latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized(this) {
_numInternalProcessing--;
_numActive++;
}
return latch.getPair().value;
}
catch (Throwable e) {
try {
_factory.destroyObject(latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
_numInternalProcessing--;
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
private synchronized void allocate() {
if (isClosed()) return;
for (;;) {
if (!_pool.isEmpty() && !_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setPair((ObjectTimestampPair) _pool.removeFirst());
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
for(;;) {
if((!_allocationQueue.isEmpty()) && (_maxActive < 0 || (_numActive + _numInternalProcessing) < _maxActive)) {
Latch latch = (Latch) _allocationQueue.removeFirst();
latch.setMayCreate(true);
_numInternalProcessing++;
synchronized (latch) {
latch.notify();
}
} else {
break;
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} finally {
synchronized (this) {
_numActive--;
allocate();
}
}
}
public void clear() {
List toDestroy = new ArrayList();
synchronized(this) {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
destroy(toDestroy);
}
private void destroy(Collection c) {
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_numInternalProcessing--;
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
synchronized (this) {
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
if (decrementNumActive) {
_numActive--;
}
allocate();
}
}
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
_numActive--;
allocate();
}
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
List toDestroy = new ArrayList();
synchronized (this) {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
toDestroy.addAll(_pool);
_numInternalProcessing = _numInternalProcessing + _pool._size;
_pool.clear();
}
_factory = factory;
}
destroy(toDestroy);
}
public void evict() throws Exception {
assertOpen();
synchronized (this) {
if(_pool.isEmpty()) {
return;
}
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
}
for (int i=0,m=getNumTests();i<m;i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_numInternalProcessing++;
}
boolean removeObject = false;
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((getMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getMinEvictableIdleTimeMillis())) {
removeObject = true;
} else if ((getSoftMinEvictableIdleTimeMillis() > 0) &&
(idleTimeMilis > getSoftMinEvictableIdleTimeMillis()) &&
((getNumIdle() + 1)> getMinIdle())) { 
removeObject = true;
}
if(getTestWhileIdle() && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
if(!removeObject) {
_evictionCursor.add(pair);
if (_lifo) {
_evictionCursor.previous();
}
}
_numInternalProcessing--;
}
}
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit(false);
for ( int j = 0 ; j < objectDeficit && calculateDeficit(true) > 0 ; j++ ) {
try {
addObject();
} finally {
synchronized (this) {
_numInternalProcessing--;
allocate();
}
}
}
}
private synchronized int calculateDeficit(boolean incrementInternal) {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0,
getMaxActive() - getNumActive() - getNumIdle() - _numInternalProcessing);
objectDeficit = Math.min(objectDeficit, growLimit);
}
if (incrementInternal && objectDeficit >0) {
_numInternalProcessing++;
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil(_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
private int _numInternalProcessing = 0;
private LinkedList _allocationQueue = new LinkedList();
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0
"Stack stack = (Stack)(_pools.get(key));
",0
"} catch (Exception e) {
",0
"if (!idleQueue.offerFirst(this)) {
",0
"borrowedCount++;
",0
"ObjectDeque<T> queue = poolMap.get(key);
",0
"} catch (Exception e1) {
",0
"} catch (Exception e) {
",0
"ObjectDeque<T> queue = poolMap.get(key);
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public synchronized int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0
"} catch (Exception e2) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"if (!idleQueue.offerFirst(this)) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception ex2) {
",0
"} catch(Exception e) {
",0
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
} catch(InterruptedException e) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0
"} catch (Exception e2) {
",0
"latch.notify();
",0
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0
"catch (Exception e) {
",0
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"latch.notify();
",0
"} catch(Exception e) {
",0
"} catch (Exception ex2) {
",0
"latch.notify();
",0
"Stack stack = (Stack)(_pools.get(key));
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0
"latch.notify();
",0
"ObjectQueue pool = _poolMap.get(key);
",0
"latch.notify();
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"l.notify();
",0
"_activeCount.put(key,new Integer(1));
",0
"this(null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
@Deprecated
public StackObjectPool(int maxIdle) {
this(null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
@Deprecated
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this(null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory<T> factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory<T> factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory<T> factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack<T>();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
@Override
public synchronized T borrowObject() throws Exception {
assertOpen();
T obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
obj = _factory.makeObject();
newlyCreated = true;
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
@Override
public synchronized void returnObject(T obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
T toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Override
public synchronized void invalidateObject(T obj) throws Exception {
_numActive--;
if (null != _factory) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
@Override
public synchronized int getNumIdle() {
return _pool.size();
}
@Override
public synchronized int getNumActive() {
return _numActive;
}
@Override
public synchronized void clear() {
if(null != _factory) {
Iterator<T> it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
@Override
public void close() throws Exception {
super.close();
clear();
}
@Override
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
T obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if (success) {
T toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
@Deprecated
@Override
public synchronized void setFactory(PoolableObjectFactory<T> factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
@Deprecated
protected Stack<T> _pool = null;
@Deprecated
protected PoolableObjectFactory<T> _factory = null;
@Deprecated
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
@Deprecated
protected int _numActive = 0;
public synchronized PoolableObjectFactory<T> getFactory() {
return _factory;
}
public int getMaxSleeping() {
return _maxSleeping;
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public void setMaxActive(int maxActive) {
synchronized(this) {
_maxActive = maxActive;
}
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public void setMaxTotal(int maxTotal) {
synchronized(this) {
_maxTotal = maxTotal;
}
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public void setWhenExhaustedAction(byte whenExhaustedAction) {
synchronized(this) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
allocate();
}
public synchronized long getMaxWait() {
return _maxWait;
}
public void setMaxWait(long maxWait) {
synchronized(this) {
_maxWait = maxWait;
}
allocate();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public void setMaxIdle(int maxIdle) {
synchronized(this) {
_maxIdle = maxIdle;
}
allocate();
}
public void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public int getMinIdle() {
int maxIdle = getMaxIdle();
if (_minIdle > maxIdle) {
return maxIdle;
} else {
return _minIdle;
}
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
}
allocate();
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
if (latch.getPair() != null || latch.mayCreate()) {
break;
}
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (latch.getPair() == null && !latch.mayCreate()) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
} else {
break;
}
}
if(isClosed() == true) {
throw new IllegalStateException(""Pool closed"");
}
} catch(InterruptedException e) {
boolean doAllocate = false;
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else if (latch.getPair() == null && latch.mayCreate()) {
latch.getPool().decrementInternalProcessingCount();
doAllocate = true;
} else {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
returnObject(latch.getkey(), latch.getPair().getValue());
}
}
if (doAllocate) {
allocate();
}
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
synchronized (this) {
if (latch.getPair() == null && !latch.mayCreate()) {
_allocationQueue.remove(latch);
} else {
break;
}
}
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
}
allocate();
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
PoolUtils.checkRethrow(e);
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
PoolUtils.checkRethrow(e2);
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
if (!newlyCreated) {
latch.reset();
_allocationQueue.add(0, latch);
}
}
allocate();
if (newlyCreated) {
NoSuchElementException nsee = new NoSuchElementException(
""Unable to validate object"");
nsee.initCause(e);
throw nsee;
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
Iterator allocationQueueIter = _allocationQueue.iterator();
while (allocationQueueIter.hasNext()) {
Latch latch = (Latch) allocationQueueIter.next();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
allocationQueueIter.remove();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
allocationQueueIter.remove();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
if (_maxActive < 0) {
break;
}
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
destroy(toDestroy, _factory);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
ObjectQueue objectQueue = (ObjectQueue)_poolMap.get(key);
final CursorableLinkedList list = objectQueue.queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
itemsToRemove--;
}
}
destroy(toDestroy, _factory);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
destroy(toDestroy, _factory);
}
private void destroy(Map m, KeyedPoolableObjectFactory factory) {
for (Iterator entries = m.entrySet().iterator(); entries.hasNext();) {
Map.Entry entry = (Entry) entries.next();
Object key = entry.getKey();
Collection c = (Collection) entry.getValue();
for (Iterator it = c.iterator(); it.hasNext();) {
try {
factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
ObjectQueue objectQueue =
(ObjectQueue) _poolMap.get(key);
if (objectQueue != null) {
objectQueue.decrementInternalProcessingCount();
if (objectQueue.internalProcessingCount == 0 &&
objectQueue.activeCount == 0 &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_totalInternalProcessing--;
}
}
allocate();
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
boolean doAllocate = false;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
doAllocate = true;
}
}
}
if (doAllocate) {
allocate();
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
if (pool.queue.isEmpty() &&
pool.activeCount == 0 &&
pool.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
allocate();
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
}
allocate(); 
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
while(_allocationQueue.size() > 0) {
Latch l = (Latch) _allocationQueue.removeFirst();
synchronized (l) {
l.notify();
}
}
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
final KeyedPoolableObjectFactory oldFactory = _factory;
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
List objects = new ArrayList();
objects.addAll(pool.queue);
toDestroy.put(key, objects);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
pool.queue.clear();
}
}
_factory = factory;
_factoryClassLoader = Thread.currentThread().getContextClassLoader();
}
}
destroy(toDestroy, oldFactory);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
ObjectQueue objectQueue = (ObjectQueue) _poolMap.get(key);
objectQueue.incrementInternalProcessingCount();
_totalIdle--;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
}
}
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
objectQueue.decrementInternalProcessingCount();
if (removeObject) {
if (objectQueue.queue.isEmpty() &&
objectQueue.activeCount == 0 &&
objectQueue.internalProcessingCount == 0) {
_poolMap.remove(key);
_poolList.remove(key);
}
} else {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
}
}
allocate();
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (getMinIdle() > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDeficit(pool, false);
for (int i = 0; i < objectDeficit && calculateDeficit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
}
allocate();
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
Object key = it.next();
buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _totalIdle);
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDeficit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
//CHECKSTYLE: stop VisibilityModifier
Object value;
long tstamp;
//CHECKSTYLE: resume VisibilityModifier
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
public Object getValue() {
return value;
}
public long getTstamp() {
return tstamp;
}
}
private class Evictor extends TimerTask {
public void run() {
ClassLoader savedClassLoader =
Thread.currentThread().getContextClassLoader();
try {
Thread.currentThread().setContextClassLoader(
_factoryClassLoader);
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
} finally {
Thread.currentThread().setContextClassLoader(savedClassLoader);
}
}
}
public static class Config {
//CHECKSTYLE: stop VisibilityModifier
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
//CHECKSTYLE: resume VisibilityModifier
}
private static final class Latch {
private final Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private volatile int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private ClassLoader _factoryClassLoader = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0
"latch.notify();
",0
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0
"} catch(Exception e) {
",0
"Stack s = (Stack)(_pools.get(key));
",0
"Stack stack = (Stack)(_pools.get(key));
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
private int minIdlePerKey;,0
private boolean testOnBorrow;,0
"catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"} catch (Exception ex2) {
",0
private int maxTotal;,0
private boolean lifo;,0
private WhenExhaustedAction whenExhaustedAction;,0
private boolean testWhileIdle;,0
private boolean testOnBorrow;,0
private long timeBetweenEvictionRunsMillis;,0
private boolean testOnReturn;,0
private int numTestsPerEvictionRun;,0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"public class GenericKeyedObjectPool extends BaseKeyedObjectPool implements KeyedObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final int DEFAULT_MAX_TOTAL  = -1;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = false;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final int DEFAULT_MIN_IDLE = 0;
public static final boolean DEFAULT_LIFO = true;
public GenericKeyedObjectPool() {
this(null, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory, DEFAULT_MAX_ACTIVE, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, GenericKeyedObjectPool.Config config) {
this(factory, config.maxActive, config.whenExhaustedAction, config.maxWait, config.maxIdle, config.maxTotal,
config.minIdle, config.testOnBorrow, config.testOnReturn, config.timeBetweenEvictionRunsMillis,
config.numTestsPerEvictionRun, config.minEvictableIdleTimeMillis, config.testWhileIdle, config.lifo);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive) {
this(factory,maxActive, DEFAULT_WHEN_EXHAUSTED_ACTION, DEFAULT_MAX_WAIT, DEFAULT_MAX_IDLE,
DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,
DEFAULT_NUM_TESTS_PER_EVICTION_RUN, DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE, DEFAULT_TEST_ON_BORROW,
DEFAULT_TEST_ON_RETURN, DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, DEFAULT_MAX_IDLE,testOnBorrow,testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_TEST_ON_BORROW, DEFAULT_TEST_ON_RETURN,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, testOnBorrow, testOnReturn,
DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS, DEFAULT_NUM_TESTS_PER_EVICTION_RUN,
DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS, DEFAULT_TEST_WHILE_IDLE);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis,
int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, GenericKeyedObjectPool.DEFAULT_MAX_TOTAL,
testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun,
minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal,
GenericKeyedObjectPool.DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis,
numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, maxTotal, minIdle, testOnBorrow, testOnReturn,
timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle,
DEFAULT_LIFO);
}
public GenericKeyedObjectPool(KeyedPoolableObjectFactory factory, int maxActive, byte whenExhaustedAction,
long maxWait, int maxIdle, int maxTotal, int minIdle, boolean testOnBorrow, boolean testOnReturn,
long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis,
boolean testWhileIdle, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch (whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_maxTotal = maxTotal;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_poolMap = new HashMap();
_poolList = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
allocate();
}
public synchronized int getMaxTotal() {
return _maxTotal;
}
public synchronized void setMaxTotal(int maxTotal) {
_maxTotal = maxTotal;
allocate();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
allocate();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
allocate();
}
public synchronized void setMinIdle(int poolSize) {
_minIdle = poolSize;
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized void setConfig(GenericKeyedObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMaxActive(conf.maxActive);
setMaxTotal(conf.maxTotal);
setMinIdle(conf.minIdle);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public Object borrowObject(Object key) throws Exception {
long starttime = System.currentTimeMillis();
Latch latch = new Latch(key);
byte whenExhaustedAction;
long maxWait;
synchronized (this) {
whenExhaustedAction = _whenExhaustedAction;
maxWait = _maxWait;
_allocationQueue.add(latch);
allocate();
}
for(;;) {
synchronized (this) {
assertOpen();
}
if (null == latch.getPair()) {
if (latch.mayCreate()) {
} else {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
synchronized (this) {
_allocationQueue.remove(latch);
latch.getPool().incrementInternalProcessingCount();
}
break;
case WHEN_EXHAUSTED_FAIL:
synchronized (this) {
_allocationQueue.remove(latch);
}
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
synchronized (latch) {
if (maxWait <= 0) {
latch.wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = maxWait - elapsed;
if (waitTime > 0)
{
latch.wait(waitTime);
}
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if (maxWait > 0 && ((System.currentTimeMillis() - starttime) >= maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction +
"" not recognized."");
}
}
}
boolean newlyCreated = false;
if (null == latch.getPair()) {
try {
Object obj = _factory.makeObject(key);
latch.setPair(new ObjectTimestampPair(obj));
newlyCreated = true;
} finally {
if (!newlyCreated) {
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
allocate();
}
}
}
}
try {
_factory.activateObject(key, latch.getPair().value);
if (_testOnBorrow && !_factory.validateObject(key, latch.getPair().value)) {
throw new Exception(""ValidateObject failed"");
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.getPool().incrementActiveCount();
}
return latch.getPair().value;
} catch (Throwable e) {
try {
_factory.destroyObject(key, latch.getPair().value);
} catch (Throwable e2) {
}
synchronized (this) {
latch.getPool().decrementInternalProcessingCount();
latch.reset();
_allocationQueue.add(0, latch);
allocate();
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
e.getMessage());
}
else {
continue; 
}
}
}
}
private void allocate() {
boolean clearOldest = false;
synchronized (this) {
if (isClosed()) return;
for (;;) {
if (!_allocationQueue.isEmpty()) {
Latch latch = (Latch) _allocationQueue.getFirst();
ObjectQueue pool = (ObjectQueue)(_poolMap.get(latch.getkey()));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(latch.getkey(), pool);
_poolList.add(latch.getkey());
}
latch.setPool(pool);
if (!pool.queue.isEmpty()) {
_allocationQueue.removeFirst();
latch.setPair(
(ObjectTimestampPair) pool.queue.removeFirst());
pool.incrementInternalProcessingCount();
_totalIdle--;
synchronized (latch) {
latch.notify();
}
continue;
}
if ((_maxTotal > 0) &&
(_totalActive + _totalIdle + _totalInternalProcessing >= _maxTotal)) {
clearOldest = true;
break;
}
if ((_maxActive < 0 || pool.activeCount + pool.internalProcessingCount < _maxActive) &&
(_maxTotal < 0 || _totalActive + _totalIdle + _totalInternalProcessing < _maxTotal)) {
_allocationQueue.removeFirst();
latch.setMayCreate(true);
pool.incrementInternalProcessingCount();
synchronized (latch) {
latch.notify();
}
continue;
}
}
break;
}
}
if (clearOldest) {
clearOldest();
}
}
public void clear() {
Map toDestroy = new HashMap();
synchronized (this) {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
toDestroy.put(key, pool.queue);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
}
}
destroy(toDestroy);
}
public void clearOldest() {
final Map toDestroy = new HashMap();
final Map map = new TreeMap();
synchronized (this) {
for (Iterator keyiter = _poolMap.keySet().iterator(); keyiter.hasNext();) {
final Object key = keyiter.next();
final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
for (Iterator it = list.iterator(); it.hasNext();) {
map.put(it.next(), key);
}
}
Set setPairKeys = map.entrySet();
int itemsToRemove = ((int) (map.size() * 0.15)) + 1;
Iterator iter = setPairKeys.iterator();
while (iter.hasNext() && itemsToRemove > 0) {
Map.Entry entry = (Map.Entry) iter.next();
Object key = entry.getValue();
ObjectTimestampPair pairTimeStamp = (ObjectTimestampPair) entry.getKey();
final CursorableLinkedList list =
((ObjectQueue)(_poolMap.get(key))).queue;
list.remove(pairTimeStamp);
if (toDestroy.containsKey(key)) {
((List)toDestroy.get(key)).add(pairTimeStamp);
} else {
List listForKey = new ArrayList();
listForKey.add(pairTimeStamp);
toDestroy.put(key, listForKey);
}
if (list.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
_totalIdle--;
_totalInternalProcessing++;
itemsToRemove--;
}
}
destroy(toDestroy);
}
public void clear(Object key) {
Map toDestroy = new HashMap();
final ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue)(_poolMap.remove(key));
if (pool == null) {
return;
} else {
_poolList.remove(key);
}
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
toDestroy.put(key, pool.queue);
}
destroy(toDestroy);
}
private void destroy(Map m) {
for (Iterator keys = m.keySet().iterator(); keys.hasNext();) {
Object key = keys.next();
Collection c = (Collection) m.get(key);
for (Iterator it = c.iterator(); it.hasNext();) {
try {
_factory.destroyObject(
key,((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
} finally {
synchronized(this) {
_totalInternalProcessing--;
allocate();
}
}
}
}
}
public synchronized int getNumActive() {
return _totalActive;
}
public synchronized int getNumIdle() {
return _totalIdle;
}
public synchronized int getNumActive(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.activeCount : 0;
}
public synchronized int getNumIdle(Object key) {
final ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
return pool != null ? pool.queue.size() : 0;
}
public void returnObject(Object key, Object obj) throws Exception {
try {
addObjectToPool(key, obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
// TODO: Correctness here depends on control in addObjectToPool.
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
}
private void addObjectToPool(Object key, Object obj,
boolean decrementNumActive) throws Exception {
boolean success = true; 
if (_testOnReturn && !_factory.validateObject(key, obj)) {
success = false;
} else {
_factory.passivateObject(key, obj);
}
boolean shouldDestroy = !success;
ObjectQueue pool;
synchronized (this) {
pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
if (isClosed()) {
shouldDestroy = true;
} else {
if (_maxIdle >= 0 && (pool.queue.size() >= _maxIdle)) {
shouldDestroy = true;
} else if (success) {
if (_lifo) {
pool.queue.addFirst(new ObjectTimestampPair(obj));
} else {
pool.queue.addLast(new ObjectTimestampPair(obj));
}
_totalIdle++;
if (decrementNumActive) {
pool.decrementActiveCount();
}
allocate();
}
}
}
if (shouldDestroy) {
try {
_factory.destroyObject(key, obj);
} catch(Exception e) {
}
if (decrementNumActive) {
synchronized(this) {
pool.decrementActiveCount();
allocate();
}
}
}
}
public void invalidateObject(Object key, Object obj) throws Exception {
try {
_factory.destroyObject(key, obj);
} finally {
synchronized (this) {
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key, pool);
_poolList.add(key);
}
pool.decrementActiveCount();
allocate(); 
}
}
}
public void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
assertOpen();
addObjectToPool(key, obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(key, obj);
} catch (Exception ex2) {
}
throw ex;
}
}
public synchronized void preparePool(Object key, boolean populateImmediately) {
ObjectQueue pool = (ObjectQueue)(_poolMap.get(key));
if (null == pool) {
pool = new ObjectQueue();
_poolMap.put(key,pool);
_poolList.add(key);
}
if (populateImmediately) {
try {
ensureMinIdle(key);
}
catch (Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
if (null != _evictionKeyCursor) {
_evictionKeyCursor.close();
_evictionKeyCursor = null;
}
startEvictor(-1L);
}
}
public void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
Map toDestroy = new HashMap();
synchronized (this) {
assertOpen();
if (0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
for (Iterator it = _poolMap.keySet().iterator(); it.hasNext();) {
Object key = it.next();
ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
if (pool != null) {
toDestroy.put(key, pool.queue);
it.remove();
_poolList.remove(key);
_totalIdle = _totalIdle - pool.queue.size();
_totalInternalProcessing =
_totalInternalProcessing + pool.queue.size();
}
}
destroy(toDestroy);
_factory = factory;
}
}
destroy(toDestroy);
}
public void evict() throws Exception {
Object key = null;
boolean testWhileIdle;
long minEvictableIdleTimeMillis;
synchronized (this) {
testWhileIdle = _testWhileIdle;
minEvictableIdleTimeMillis = _minEvictableIdleTimeMillis;
if (_evictionKeyCursor != null &&
_evictionKeyCursor._lastReturned != null) {
key = _evictionKeyCursor._lastReturned.value();
}
}
for (int i=0, m=getNumTests(); i<m; i++) {
final ObjectTimestampPair pair;
synchronized (this) {
if (_poolMap == null || _poolMap.size() == 0) {
continue;
}
if (null == _evictionKeyCursor) {
resetEvictionKeyCursor();
key = null;
}
if (null == _evictionCursor) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else {
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
if (_evictionCursor == null) {
continue; 
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
} else { 
resetEvictionKeyCursor();
if (_evictionKeyCursor != null) {
if (_evictionKeyCursor.hasNext()) {
key = _evictionKeyCursor.next();
resetEvictionObjectCursor(key);
}
}
}
}
}
if ((_lifo && !_evictionCursor.hasPrevious()) ||
(!_lifo && !_evictionCursor.hasNext())) {
continue; 
}
pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
_evictionCursor.remove();
_totalIdle--;
_totalInternalProcessing++;
}
boolean removeObject=false;
if ((minEvictableIdleTimeMillis > 0) &&
(System.currentTimeMillis() - pair.tstamp >
minEvictableIdleTimeMillis)) {
removeObject=true;
}
if (testWhileIdle && removeObject == false) {
boolean active = false;
try {
_factory.activateObject(key,pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if (active) {
if (!_factory.validateObject(key,pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(key,pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if (removeObject) {
try {
_factory.destroyObject(key, pair.value);
} catch(Exception e) {
} finally {
if (_minIdle == 0) {
synchronized (this) {
ObjectQueue objectQueue =
(ObjectQueue)_poolMap.get(key);
if (objectQueue != null &&
objectQueue.queue.isEmpty()) {
_poolMap.remove(key);
_poolList.remove(key);
}
}
}
}
}
synchronized (this) {
if (!removeObject) {
_evictionCursor.add(pair);
_totalIdle++;
if (_lifo) {
_evictionCursor.previous();
}
}
_totalInternalProcessing--;
}
}
}
private void resetEvictionKeyCursor() {
if (_evictionKeyCursor != null) {
_evictionKeyCursor.close();
}
_evictionKeyCursor = _poolList.cursor();
if (null != _evictionCursor) {
_evictionCursor.close();
_evictionCursor = null;
}
}
private void resetEvictionObjectCursor(Object key) {
if (_evictionCursor != null) {
_evictionCursor.close();
}
if (_poolMap == null) {
return;
}
ObjectQueue pool = (ObjectQueue) (_poolMap.get(key));
if (pool != null) {
CursorableLinkedList queue = pool.queue;
_evictionCursor = queue.cursor(_lifo ? queue.size() : 0);
}
}
private void ensureMinIdle() throws Exception {
if (_minIdle > 0) {
Object[] keysCopy;
synchronized(this) {
keysCopy = _poolMap.keySet().toArray();
}
for (int i=0; i < keysCopy.length; i++) {
ensureMinIdle(keysCopy[i]);
}
}
}
private void ensureMinIdle(Object key) throws Exception {
ObjectQueue pool;
synchronized(this) {
pool = (ObjectQueue)(_poolMap.get(key));
}
if (pool == null) {
return;
}
int objectDeficit = calculateDefecit(pool, false);
for (int i = 0; i < objectDeficit && calculateDefecit(pool, true) > 0; i++) {
try {
addObject(key);
} finally {
synchronized (this) {
pool.decrementInternalProcessingCount();
allocate();
}
}
}
}
protected synchronized void startEvictor(long delay) {
if (null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if (delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
Iterator it = _poolMap.keySet().iterator();
while (it.hasNext()) {
buf.append(""\t"").append(_poolMap.get(it.next())).append(""\n"");
}
return buf.toString();
}
private synchronized int getNumTests() {
if (_numTestsPerEvictionRun >= 0) {
return _numTestsPerEvictionRun;
} else {
return(int)(Math.ceil(_totalIdle/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private synchronized int calculateDefecit(ObjectQueue pool,
boolean incrementInternal) {
int objectDefecit = 0;
objectDefecit = getMinIdle() - pool.queue.size();
if (getMaxActive() > 0) {
int growLimit = Math.max(0, getMaxActive() - pool.activeCount - pool.queue.size() - pool.internalProcessingCount);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (getMaxTotal() > 0) {
int growLimit = Math.max(0, getMaxTotal() - getNumActive() - getNumIdle() - _totalInternalProcessing);
objectDefecit = Math.min(objectDefecit, growLimit);
}
if (incrementInternal && objectDefecit > 0) {
pool.incrementInternalProcessingCount();
}
return objectDefecit;
}
private class ObjectQueue {
private int activeCount = 0;
private final CursorableLinkedList queue = new CursorableLinkedList();
private int internalProcessingCount = 0;
void incrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive++;
}
activeCount++;
}
void decrementActiveCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalActive--;
}
if (activeCount > 0) {
activeCount--;
}
}
void incrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing++;
}
internalProcessingCount++;
}
void decrementInternalProcessingCount() {
synchronized (GenericKeyedObjectPool.this) {
_totalInternalProcessing--;
}
internalProcessingCount--;
}
}
static class ObjectTimestampPair implements Comparable {
Object value;
long tstamp;
ObjectTimestampPair(Object val) {
this(val, System.currentTimeMillis());
}
ObjectTimestampPair(Object val, long time) {
value = val;
tstamp = time;
}
public String toString() {
return value + "";"" + tstamp;
}
public int compareTo(Object obj) {
return compareTo((ObjectTimestampPair) obj);
}
public int compareTo(ObjectTimestampPair other) {
final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
}
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
} catch(OutOfMemoryError oome) {
oome.printStackTrace(System.err);
}
try {
ensureMinIdle();
} catch (Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericKeyedObjectPool.DEFAULT_MAX_IDLE;
public int maxActive = GenericKeyedObjectPool.DEFAULT_MAX_ACTIVE;
public int maxTotal = GenericKeyedObjectPool.DEFAULT_MAX_TOTAL;
public int minIdle = GenericKeyedObjectPool.DEFAULT_MIN_IDLE;
public long maxWait = GenericKeyedObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericKeyedObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericKeyedObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericKeyedObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericKeyedObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericKeyedObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericKeyedObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericKeyedObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericKeyedObjectPool.DEFAULT_LIFO;
}
private static final class Latch {
private Object _key;
private ObjectQueue _pool;
private ObjectTimestampPair _pair;
private boolean _mayCreate = false;
private Latch(Object key) {
_key = key;
}
private synchronized Object getkey() {
return _key;
}
private synchronized ObjectQueue getPool() {
return _pool;
}
private synchronized void setPool(ObjectQueue pool) {
_pool = pool;
}
private synchronized ObjectTimestampPair getPair() {
return _pair;
}
private synchronized void setPair(ObjectTimestampPair pair) {
_pair = pair;
}
private synchronized boolean mayCreate() {
return _mayCreate;
}
private synchronized void setMayCreate(boolean mayCreate) {
_mayCreate = mayCreate;
}
private synchronized void reset() {
_pair = null;
_mayCreate = false;
}
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private int _maxTotal = DEFAULT_MAX_TOTAL;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private Map _poolMap = null;
private int _totalActive = 0;
private int _totalIdle = 0;
private int _totalInternalProcessing = 0;
private KeyedPoolableObjectFactory _factory = null;
private Evictor _evictor = null;
private CursorableLinkedList _poolList = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private CursorableLinkedList.Cursor _evictionKeyCursor = null;
private boolean _lifo = DEFAULT_LIFO;
private LinkedList _allocationQueue = new LinkedList();
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0
"Stack s = (Stack)(_pools.get(key));
",0
"Stack stack = (Stack)(_pools.get(key));
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"if (!idleQueue.offerFirst(this)) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"borrowedCount++;
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"private final Map objectPools = new HashMap();
// XXX: Add better handling of when this instance is not Serializable
private final ObjectPoolFactory poolFactory;
private final transient ThreadLocal keys;
private volatile boolean open = true;
CompositeKeyedObjectPool(final ObjectPoolFactory poolFactory) throws IllegalArgumentException {
if (poolFactory == null) {
throw new IllegalArgumentException(""object pool factory must not be null."");
}
this.poolFactory = poolFactory;
if (poolFactory instanceof CompositeObjectPoolFactory) {
final PoolableObjectFactory pof = ((CompositeObjectPoolFactory)poolFactory).getFactory();
if (pof instanceof KeyedPoolableObjectFactoryAdapter) {
keys = new ThreadLocal();
((KeyedPoolableObjectFactoryAdapter)pof).setCompositeKeyedObjectPool(this);
} else {
keys = null;
}
} else {
keys = null;
}
}
private ObjectPool getObjectPool(final Object key) {
ObjectPool pool;
synchronized (objectPools) {
pool = (ObjectPool)objectPools.get(key);
if (pool == null) {
pool = poolFactory.createPool();
objectPools.put(key, pool);
if (pool instanceof CompositeObjectPool) {
((CompositeObjectPool)pool).setOwningCompositeKeyedObjectPool(this);
}
}
}
return pool;
}
public Object borrowObject(final Object key) throws Exception {
assertOpen();
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
return pool.borrowObject();
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public void returnObject(final Object key, final Object obj) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.returnObject(obj);
} catch (Exception e) {
// XXX: In pool 3 this catch block will not be necessary and shouled be removed
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public void invalidateObject(final Object key, final Object obj) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.invalidateObject(obj);
} catch (Exception e) {
// XXX: In pool 3 this catch block will not be necessary and shouled be removed
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public void addObject(final Object key) throws Exception {
assertOpen();
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.addObject();
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public int getNumIdle(final Object key) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
return pool.getNumIdle();
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public int getNumActive(final Object key) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
return pool.getNumActive();
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public int getNumIdle() {
int numIdle = 0;
synchronized (objectPools) {
final Iterator iter = objectPools.values().iterator();
while (iter.hasNext()) {
final ObjectPool pool = (ObjectPool)iter.next();
numIdle += pool.getNumIdle();
}
}
return numIdle;
}
public int getNumActive() {
int numActive = 0;
synchronized (objectPools) {
final Iterator iter = objectPools.values().iterator();
while (iter.hasNext()) {
final ObjectPool pool = (ObjectPool)iter.next();
numActive += pool.getNumActive();
}
}
return numActive;
}
public void clear() throws Exception {
synchronized (objectPools) {
final Iterator iter = objectPools.keySet().iterator();
while (iter.hasNext()) {
final Object key = iter.next();
clear(key);
}
}
}
public void clear(final Object key) throws Exception {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.clear();
synchronized (objectPools) {
if (pool.getNumActive() == 0) {
objectPools.remove(key);
pool.close();
}
}
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public void close() {
open = false;
Thread.yield(); 
synchronized (objectPools) {
final Iterator iter = objectPools.keySet().iterator();
while (iter.hasNext()) {
final Object key = iter.next();
close(key);
}
}
}
private void close(final Object key) {
final ObjectPool pool = getObjectPool(key);
try {
if (keys != null) {
keys.set(key);
}
pool.close();
synchronized (objectPools) {
if (pool.getNumActive() == 0) {
objectPools.remove(key);
pool.close();
}
}
} catch (Exception e) {
// XXX: In pool 3 this catch block will not be necessary and shouled be removed
} finally {
if (keys != null) {
keys.set(null); 
}
}
}
public void setFactory(final KeyedPoolableObjectFactory factory) throws IllegalStateException, UnsupportedOperationException {
throw new UnsupportedOperationException(""Replacing the factory not supported. Create a new pool instance instead."");
}
private void assertOpen() throws IllegalStateException {
if (!open) {
throw new IllegalStateException(""keyed pool has been closed."");
}
}
ThreadLocal getKeys() {
return keys;
}
public String toString() {
final StringBuffer sb = new StringBuffer(128);
sb.append(""CompositeKeyedObjectPool{"");
sb.append(""poolFactory="").append(poolFactory);
sb.append("", open="").append(open);
try {
final int numActive = getNumActive();
sb.append("", activeObjects="").append(numActive);
} catch (Exception e) {
}
try {
final int numIdle = getNumIdle();
sb.append("", idleObjects="").append(numIdle);
} catch (Exception e) {
}
sb.append('}');
return sb.toString();
}
private Object readResolve() throws ObjectStreamException {
final CompositeKeyedObjectPool pool = new CompositeKeyedObjectPool(poolFactory);
if (!open) {
try {
pool.close();
} catch (Exception e) {
final InvalidObjectException ioe = new InvalidObjectException(""pool close failed on serialized closed pool."");
ioe.initCause(e);
throw ioe;
}
}
return pool;
",0
"final CursorableLinkedList list = ((ObjectQueue)_poolMap.get(key)).queue;
",0
"} catch(Exception e) {
",0
"public class GenericObjectPool extends BaseObjectPool implements ObjectPool {
public static final byte WHEN_EXHAUSTED_FAIL   = 0;
public static final byte WHEN_EXHAUSTED_BLOCK  = 1;
public static final byte WHEN_EXHAUSTED_GROW   = 2;
public static final int DEFAULT_MAX_IDLE  = 8;
public static final int DEFAULT_MIN_IDLE = 0;
public static final int DEFAULT_MAX_ACTIVE  = 8;
public static final byte DEFAULT_WHEN_EXHAUSTED_ACTION = WHEN_EXHAUSTED_BLOCK;
public static final boolean DEFAULT_LIFO = true;
public static final long DEFAULT_MAX_WAIT = -1L;
public static final boolean DEFAULT_TEST_ON_BORROW = true;
public static final boolean DEFAULT_TEST_ON_RETURN = false;
public static final boolean DEFAULT_TEST_WHILE_IDLE = false;
public static final long DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS = -1L;
public static final int DEFAULT_NUM_TESTS_PER_EVICTION_RUN = 3;
public static final long DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS = 1000L * 60L * 30L;
public static final long DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS = -1;
public GenericObjectPool() {
this(null,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_ACTIVE,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, GenericObjectPool.Config config) {
this(factory,config.maxActive,config.whenExhaustedAction,config.maxWait,config.maxIdle,config.minIdle,config.testOnBorrow,config.testOnReturn,config.timeBetweenEvictionRunsMillis,config.numTestsPerEvictionRun,config.minEvictableIdleTimeMillis,config.testWhileIdle,config.softMinEvictableIdleTimeMillis, config.lifo);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive) {
this(factory,maxActive,DEFAULT_WHEN_EXHAUSTED_ACTION,DEFAULT_MAX_WAIT,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,DEFAULT_MAX_IDLE,DEFAULT_MIN_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_MIN_IDLE,DEFAULT_TEST_ON_BORROW,DEFAULT_TEST_ON_RETURN,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn) {
this(factory,maxActive,whenExhaustedAction,maxWait,maxIdle,DEFAULT_MIN_IDLE,testOnBorrow,testOnReturn,DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS,DEFAULT_NUM_TESTS_PER_EVICTION_RUN,DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS,DEFAULT_TEST_WHILE_IDLE);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, DEFAULT_MIN_IDLE, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, long softMinEvictableIdleTimeMillis) {
this(factory, maxActive, whenExhaustedAction, maxWait, maxIdle, minIdle, testOnBorrow, testOnReturn, timeBetweenEvictionRunsMillis, numTestsPerEvictionRun, minEvictableIdleTimeMillis, testWhileIdle, softMinEvictableIdleTimeMillis, DEFAULT_LIFO);
}
public GenericObjectPool(PoolableObjectFactory factory, int maxActive, byte whenExhaustedAction, long maxWait, int maxIdle, int minIdle, boolean testOnBorrow, boolean testOnReturn, long timeBetweenEvictionRunsMillis, int numTestsPerEvictionRun, long minEvictableIdleTimeMillis, boolean testWhileIdle, long softMinEvictableIdleTimeMillis, boolean lifo) {
_factory = factory;
_maxActive = maxActive;
_lifo = lifo;
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
_maxWait = maxWait;
_maxIdle = maxIdle;
_minIdle = minIdle;
_testOnBorrow = testOnBorrow;
_testOnReturn = testOnReturn;
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
_numTestsPerEvictionRun = numTestsPerEvictionRun;
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
_testWhileIdle = testWhileIdle;
_pool = new CursorableLinkedList();
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getMaxActive() {
return _maxActive;
}
public synchronized void setMaxActive(int maxActive) {
_maxActive = maxActive;
notifyAll();
}
public synchronized byte getWhenExhaustedAction() {
return _whenExhaustedAction;
}
public synchronized void setWhenExhaustedAction(byte whenExhaustedAction) {
switch(whenExhaustedAction) {
case WHEN_EXHAUSTED_BLOCK:
case WHEN_EXHAUSTED_FAIL:
case WHEN_EXHAUSTED_GROW:
_whenExhaustedAction = whenExhaustedAction;
notifyAll();
break;
default:
throw new IllegalArgumentException(""whenExhaustedAction "" + whenExhaustedAction + "" not recognized."");
}
}
public synchronized long getMaxWait() {
return _maxWait;
}
public synchronized void setMaxWait(long maxWait) {
_maxWait = maxWait;
notifyAll();
}
public synchronized int getMaxIdle() {
return _maxIdle;
}
public synchronized void setMaxIdle(int maxIdle) {
_maxIdle = maxIdle;
notifyAll();
}
public synchronized void setMinIdle(int minIdle) {
_minIdle = minIdle;
notifyAll();
}
public synchronized int getMinIdle() {
return _minIdle;
}
public boolean getTestOnBorrow() {
return _testOnBorrow;
}
public void setTestOnBorrow(boolean testOnBorrow) {
_testOnBorrow = testOnBorrow;
}
public boolean getTestOnReturn() {
return _testOnReturn;
}
public void setTestOnReturn(boolean testOnReturn) {
_testOnReturn = testOnReturn;
}
public synchronized long getTimeBetweenEvictionRunsMillis() {
return _timeBetweenEvictionRunsMillis;
}
public synchronized void setTimeBetweenEvictionRunsMillis(long timeBetweenEvictionRunsMillis) {
_timeBetweenEvictionRunsMillis = timeBetweenEvictionRunsMillis;
startEvictor(_timeBetweenEvictionRunsMillis);
}
public synchronized int getNumTestsPerEvictionRun() {
return _numTestsPerEvictionRun;
}
public synchronized void setNumTestsPerEvictionRun(int numTestsPerEvictionRun) {
_numTestsPerEvictionRun = numTestsPerEvictionRun;
}
public synchronized long getMinEvictableIdleTimeMillis() {
return _minEvictableIdleTimeMillis;
}
public synchronized void setMinEvictableIdleTimeMillis(long minEvictableIdleTimeMillis) {
_minEvictableIdleTimeMillis = minEvictableIdleTimeMillis;
}
public synchronized long getSoftMinEvictableIdleTimeMillis() {
return _softMinEvictableIdleTimeMillis;
}
public synchronized void setSoftMinEvictableIdleTimeMillis(long softMinEvictableIdleTimeMillis) {
_softMinEvictableIdleTimeMillis = softMinEvictableIdleTimeMillis;
}
public synchronized boolean getTestWhileIdle() {
return _testWhileIdle;
}
public synchronized void setTestWhileIdle(boolean testWhileIdle) {
_testWhileIdle = testWhileIdle;
}
public synchronized boolean getLifo() {
return _lifo;
}
public synchronized void setLifo(boolean lifo) {
this._lifo = lifo;
}
public synchronized void setConfig(GenericObjectPool.Config conf) {
setMaxIdle(conf.maxIdle);
setMinIdle(conf.minIdle);
setMaxActive(conf.maxActive);
setMaxWait(conf.maxWait);
setWhenExhaustedAction(conf.whenExhaustedAction);
setTestOnBorrow(conf.testOnBorrow);
setTestOnReturn(conf.testOnReturn);
setTestWhileIdle(conf.testWhileIdle);
setNumTestsPerEvictionRun(conf.numTestsPerEvictionRun);
setMinEvictableIdleTimeMillis(conf.minEvictableIdleTimeMillis);
setTimeBetweenEvictionRunsMillis(conf.timeBetweenEvictionRunsMillis);
setSoftMinEvictableIdleTimeMillis(conf.softMinEvictableIdleTimeMillis);
setLifo(conf.lifo);
notifyAll();
}
public Object borrowObject() throws Exception {
long starttime = System.currentTimeMillis();
for(;;) {
ObjectTimestampPair pair = null;
synchronized (this) {
assertOpen();
try {
pair = (ObjectTimestampPair)(_pool.removeFirst());
} catch(NoSuchElementException e) {
; 
}
if(null == pair) {
if(_maxActive < 0 || _numActive < _maxActive) {
} else {
switch(_whenExhaustedAction) {
case WHEN_EXHAUSTED_GROW:
break;
case WHEN_EXHAUSTED_FAIL:
throw new NoSuchElementException(""Pool exhausted"");
case WHEN_EXHAUSTED_BLOCK:
try {
if(_maxWait <= 0) {
wait();
} else {
final long elapsed = (System.currentTimeMillis() - starttime);
final long waitTime = _maxWait - elapsed;
if (waitTime > 0)
{
wait(waitTime);
}
}
} catch(InterruptedException e) {
Thread.currentThread().interrupt();
throw e;
}
if(_maxWait > 0 && ((System.currentTimeMillis() - starttime) >= _maxWait)) {
throw new NoSuchElementException(""Timeout waiting for idle object"");
} else {
continue; 
}
default:
throw new IllegalArgumentException(""WhenExhaustedAction property "" + _whenExhaustedAction + "" not recognized."");
}
}
}
_numActive++;
}
boolean newlyCreated = false;
if(null == pair) {
try {
Object obj = _factory.makeObject();
pair = new ObjectTimestampPair(obj);
newlyCreated = true;
return pair.value;
} finally {
if (!newlyCreated) {
synchronized (this) {
_numActive--;
notifyAll();
}
}
}
}
try {
_factory.activateObject(pair.value);
if(_testOnBorrow && !_factory.validateObject(pair.value)) {
throw new Exception(""ValidateObject failed"");
}
return pair.value;
}
catch (Throwable e) {
synchronized (this) {
_numActive--;
notifyAll();
}
try {
_factory.destroyObject(pair.value);
}
catch (Throwable e2) {
}
if(newlyCreated) {
throw new NoSuchElementException(""Could not create a validated object, cause: "" + e.getMessage());
}
else {
continue; 
}
}
}
}
public void invalidateObject(Object obj) throws Exception {
try {
if (_factory != null) {
_factory.destroyObject(obj);
}
} catch (Exception e) {
} finally {
synchronized (this) {
_numActive--;
notifyAll(); 
}
}
}
public synchronized void clear() {
for(Iterator it = _pool.iterator(); it.hasNext(); ) {
try {
_factory.destroyObject(((ObjectTimestampPair)(it.next())).value);
} catch(Exception e) {
}
it.remove();
}
_pool.clear();
notifyAll(); 
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized int getNumIdle() {
return _pool.size();
}
public void returnObject(Object obj) throws Exception {
try {
addObjectToPool(obj, true);
} catch (Exception e) {
if (_factory != null) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
}
}
}
}
private void addObjectToPool(Object obj, boolean decrementNumActive) throws Exception {
boolean success = true;
if(_testOnReturn && !(_factory.validateObject(obj))) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = false;
synchronized (this) {
if (decrementNumActive) {
_numActive--;
}
if (isClosed()) {
shouldDestroy = true;
} else {
if((_maxIdle >= 0) && (_pool.size() >= _maxIdle)) {
shouldDestroy = true;
} else if(success) {
if (_lifo) {
_pool.addFirst(new ObjectTimestampPair(obj));
} else {
_pool.addLast(new ObjectTimestampPair(obj));
}
}
}
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public void close() throws Exception {
super.close();
synchronized (this) {
clear();
startEvictor(-1L);
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
public synchronized void evict() throws Exception {
assertOpen();
if(!_pool.isEmpty()) {
if (null == _evictionCursor) {
_evictionCursor = (_pool.cursor(_lifo ? _pool.size() : 0));
}
for (int i=0,m=getNumTests();i<m;i++) {
if ((_lifo && !_evictionCursor.hasPrevious()) ||
!_lifo && !_evictionCursor.hasNext()) {
_evictionCursor.close();
_evictionCursor = _pool.cursor(_lifo ? _pool.size() : 0);
}
boolean removeObject = false;
final ObjectTimestampPair pair = _lifo ?
(ObjectTimestampPair) _evictionCursor.previous() :
(ObjectTimestampPair) _evictionCursor.next();
final long idleTimeMilis = System.currentTimeMillis() - pair.tstamp;
if ((_minEvictableIdleTimeMillis > 0)
&& (idleTimeMilis > _minEvictableIdleTimeMillis)) {
removeObject = true;
} else if ((_softMinEvictableIdleTimeMillis > 0)
&& (idleTimeMilis > _softMinEvictableIdleTimeMillis)
&& (getNumIdle() > getMinIdle())) {
removeObject = true;
}
if(_testWhileIdle && !removeObject) {
boolean active = false;
try {
_factory.activateObject(pair.value);
active = true;
} catch(Exception e) {
removeObject=true;
}
if(active) {
if(!_factory.validateObject(pair.value)) {
removeObject=true;
} else {
try {
_factory.passivateObject(pair.value);
} catch(Exception e) {
removeObject=true;
}
}
}
}
if(removeObject) {
try {
_evictionCursor.remove();
_factory.destroyObject(pair.value);
} catch(Exception e) {
}
}
}
} 
}
private void ensureMinIdle() throws Exception {
int objectDeficit = calculateDeficit();
for ( int j = 0 ; j < objectDeficit && calculateDeficit() > 0 ; j++ ) {
addObject();
}
}
private synchronized int calculateDeficit() {
int objectDeficit = getMinIdle() - getNumIdle();
if (_maxActive > 0) {
int growLimit = Math.max(0, getMaxActive() - getNumActive() - getNumIdle());
objectDeficit = Math.min(objectDeficit, growLimit);
}
return objectDeficit;
}
public void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
synchronized (this) {
try {
assertOpen();
addObjectToPool(obj, false);
} catch (IllegalStateException ex) { 
try {
_factory.destroyObject(obj);
} catch (Exception ex2) {
}
throw ex;
}
}
}
protected synchronized void startEvictor(long delay) {
if(null != _evictor) {
EvictionTimer.cancel(_evictor);
_evictor = null;
}
if(delay > 0) {
_evictor = new Evictor();
EvictionTimer.schedule(_evictor, delay, delay);
}
}
synchronized String debugInfo() {
StringBuffer buf = new StringBuffer();
buf.append(""Active: "").append(getNumActive()).append(""\n"");
buf.append(""Idle: "").append(getNumIdle()).append(""\n"");
buf.append(""Idle Objects:\n"");
Iterator it = _pool.iterator();
long time = System.currentTimeMillis();
while(it.hasNext()) {
ObjectTimestampPair pair = (ObjectTimestampPair)(it.next());
buf.append(""\t"").append(pair.value).append(""\t"").append(time - pair.tstamp).append(""\n"");
}
return buf.toString();
}
private int getNumTests() {
if(_numTestsPerEvictionRun >= 0) {
return Math.min(_numTestsPerEvictionRun, _pool.size());
} else {
return(int)(Math.ceil((double)_pool.size()/Math.abs((double)_numTestsPerEvictionRun)));
}
}
private class Evictor extends TimerTask {
public void run() {
try {
evict();
} catch(Exception e) {
}
try {
ensureMinIdle();
} catch(Exception e) {
}
}
}
public static class Config {
public int maxIdle = GenericObjectPool.DEFAULT_MAX_IDLE;
public int minIdle = GenericObjectPool.DEFAULT_MIN_IDLE;
public int maxActive = GenericObjectPool.DEFAULT_MAX_ACTIVE;
public long maxWait = GenericObjectPool.DEFAULT_MAX_WAIT;
public byte whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;
public boolean testOnBorrow = GenericObjectPool.DEFAULT_TEST_ON_BORROW;
public boolean testOnReturn = GenericObjectPool.DEFAULT_TEST_ON_RETURN;
public boolean testWhileIdle = GenericObjectPool.DEFAULT_TEST_WHILE_IDLE;
public long timeBetweenEvictionRunsMillis = GenericObjectPool.DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
public int numTestsPerEvictionRun =  GenericObjectPool.DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
public long minEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public long softMinEvictableIdleTimeMillis = GenericObjectPool.DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
public boolean lifo = GenericObjectPool.DEFAULT_LIFO;
}
private int _maxIdle = DEFAULT_MAX_IDLE;
private int _minIdle = DEFAULT_MIN_IDLE;
private int _maxActive = DEFAULT_MAX_ACTIVE;
private long _maxWait = DEFAULT_MAX_WAIT;
private byte _whenExhaustedAction = DEFAULT_WHEN_EXHAUSTED_ACTION;
private volatile boolean _testOnBorrow = DEFAULT_TEST_ON_BORROW;
private volatile boolean _testOnReturn = DEFAULT_TEST_ON_RETURN;
private boolean _testWhileIdle = DEFAULT_TEST_WHILE_IDLE;
private long _timeBetweenEvictionRunsMillis = DEFAULT_TIME_BETWEEN_EVICTION_RUNS_MILLIS;
private int _numTestsPerEvictionRun =  DEFAULT_NUM_TESTS_PER_EVICTION_RUN;
private long _minEvictableIdleTimeMillis = DEFAULT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private long _softMinEvictableIdleTimeMillis = DEFAULT_SOFT_MIN_EVICTABLE_IDLE_TIME_MILLIS;
private boolean _lifo = DEFAULT_LIFO;
private CursorableLinkedList _pool = null;
private CursorableLinkedList.Cursor _evictionCursor = null;
private PoolableObjectFactory _factory = null;
private int _numActive = 0;
private Evictor _evictor = null;
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
// TODO: Don't use exception, test size.
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if(!newlyMade && null != obj && null != _factory) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
obj = null;
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
try {
_factory.passivateObject(key, obj);
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
try {
_factory.destroyObject(key,obj);
} catch (Exception e) {
}
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0
"this((PoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle) {
this((PoolableObjectFactory)null,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(int maxIdle, int initIdleCapacity) {
this((PoolableObjectFactory)null,maxIdle,initIdleCapacity);
}
public StackObjectPool(PoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle) {
this(factory,maxIdle,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackObjectPool(PoolableObjectFactory factory, int maxIdle, int initIdleCapacity) {
_factory = factory;
_maxSleeping = (maxIdle < 0 ? DEFAULT_MAX_SLEEPING : maxIdle);
int initcapacity = (initIdleCapacity < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : initIdleCapacity);
_pool = new Stack();
_pool.ensureCapacity( initcapacity > _maxSleeping ? _maxSleeping : initcapacity);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while (null == obj) {
if (!_pool.empty()) {
obj = _pool.pop();
} else {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
if (obj == null) {
throw new NoSuchElementException(""PoolableObjectFactory.makeObject() returned null."");
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
try {
_factory.activateObject(obj);
} catch (Exception e) {
try {
_factory.destroyObject(obj);
} catch (Exception e2) {
} finally {
obj = null;
}
}
}
if (!newlyCreated && null != _factory && null != obj) {
boolean validated = false;
try {
validated = _factory.validateObject(obj);
} catch (Exception e) {
}
if (!validated) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
} finally {
obj = null;
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if(null != _factory) {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
boolean shouldDestroy = !success;
_numActive--;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (null != _factory) {
try {
_factory.destroyObject(obj);
} catch (Exception e) {
}
}
notifyAll(); 
}
public synchronized int getNumIdle() {
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator it = _pool.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(it.next());
} catch(Exception e) {
}
}
}
_pool.clear();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
_factory.passivateObject(obj);
boolean shouldDestroy = !success;
if (success) {
Object toBeDestroyed = null;
if(_pool.size() >= _maxSleeping) {
shouldDestroy = true;
toBeDestroyed = _pool.remove(0); 
}
_pool.push(obj);
obj = toBeDestroyed; 
}
notifyAll(); 
if(shouldDestroy) { 
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected Stack _pool = null;
protected PoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _numActive = 0;
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"private Listable<E> _prev = null;
private Listable<E> _next = null;
private E _val = null;
Listable(Listable<E> prev, Listable<E> next, E val) {
_prev = prev;
_next = next;
_val = val;
}
Listable<E> next() {
return _next;
}
Listable<E> prev() {
return _prev;
}
E value() {
return _val;
}
void setNext(Listable<E> next) {
_next = next;
}
void setPrev(Listable<E> prev) {
_prev = prev;
}
E setValue(E val) {
E temp = _val;
_val = val;
return temp;
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"} catch(Exception e) {
",0
"@Deprecated
protected int _totActive = 0;",0
"Stack<V> s = _pools.get(key);
",0
"@Deprecated
protected int _totIdle = 0;",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"buf.append(""\t"").append(key).append("" "").append(_poolMap.get(key)).append(""\n"");
",0
"ObjectQueue pool = (ObjectQueue)_poolMap.get(key);
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0
"} catch (final Exception e) {
",0
"} catch (final Exception e) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e2) {
",0
"final long tstampdiff = this.tstamp - other.tstamp;
if (tstampdiff == 0) {
return System.identityHashCode(this) - System.identityHashCode(other);
} else {
return (int)Math.min(Math.max(tstampdiff, Integer.MIN_VALUE), Integer.MAX_VALUE);
",0
"latch.notify();
",0
"} catch (Exception e2) {
",0
"public SoftReferenceObjectPool() {
_pool = new ArrayList();
_factory = null;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory) {
_pool = new ArrayList();
_factory = factory;
}
public SoftReferenceObjectPool(PoolableObjectFactory factory, int initSize) throws Exception, IllegalArgumentException {
if (factory == null) {
throw new IllegalArgumentException(""factory required to prefill the pool."");
}
_pool = new ArrayList(initSize);
_factory = factory;
PoolUtils.prefill(this, initSize);
}
public synchronized Object borrowObject() throws Exception {
assertOpen();
Object obj = null;
boolean newlyCreated = false;
while(null == obj) {
if(_pool.isEmpty()) {
if(null == _factory) {
throw new NoSuchElementException();
} else {
newlyCreated = true;
obj = _factory.makeObject();
}
} else {
SoftReference ref = (SoftReference)(_pool.remove(_pool.size() - 1));
obj = ref.get();
ref.clear(); 
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(obj);
if (!_factory.validateObject(obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
PoolUtils.checkRethrow(t);
try {
_factory.destroyObject(obj);
} catch (Throwable t2) {
PoolUtils.checkRethrow(t2);
} finally {
obj = null;
}
if (newlyCreated) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
}
_numActive++;
return obj;
}
public synchronized void returnObject(Object obj) throws Exception {
boolean success = !isClosed();
if (_factory != null) {
if(!_factory.validateObject(obj)) {
success = false;
} else {
try {
_factory.passivateObject(obj);
} catch(Exception e) {
success = false;
}
}
}
boolean shouldDestroy = !success;
_numActive--;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
}
notifyAll(); 
if (shouldDestroy && _factory != null) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized void invalidateObject(Object obj) throws Exception {
_numActive--;
if (_factory != null) {
_factory.destroyObject(obj);
}
notifyAll(); 
}
public synchronized void addObject() throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject();
boolean success = true;
if(!_factory.validateObject(obj)) {
success = false;
} else {
_factory.passivateObject(obj);
}
boolean shouldDestroy = !success;
if(success) {
_pool.add(new SoftReference(obj, refQueue));
notifyAll(); 
}
if(shouldDestroy) {
try {
_factory.destroyObject(obj);
} catch(Exception e) {
}
}
}
public synchronized int getNumIdle() {
pruneClearedReferences();
return _pool.size();
}
public synchronized int getNumActive() {
return _numActive;
}
public synchronized void clear() {
if(null != _factory) {
Iterator iter = _pool.iterator();
while(iter.hasNext()) {
try {
Object obj = ((SoftReference)iter.next()).get();
if(null != obj) {
_factory.destroyObject(obj);
}
} catch(Exception e) {
}
}
}
_pool.clear();
pruneClearedReferences();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(PoolableObjectFactory factory) throws IllegalStateException {
assertOpen();
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private void pruneClearedReferences() {
Reference ref;
while ((ref = refQueue.poll()) != null) {
try {
_pool.remove(ref);
} catch (UnsupportedOperationException uoe) {
}
}
}
public synchronized PoolableObjectFactory getFactory() {
return _factory;
}
private List _pool = null;
private PoolableObjectFactory _factory = null;
private final ReferenceQueue refQueue = new ReferenceQueue();
private int _numActive = 0;
",0
protected int _totActive = 0;,0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"final ObjectDeque<T> deque = poolMap.get(k);
",0
"} catch (final Exception e) {
",0
"} catch (final Exception e) {
",0
"scheduledFuture.cancel(false);
",0
"borrowedCount++;
",0
private long createCount = 0;,0
"} catch (final Exception ignored) {
",0
"throw (Error) validationThrowable;
",0
"} catch (final Exception ignored) {
",0
private int numActive;,0
"if (!idleQueue.offerFirst(this)) {
",0
"throw (Error) validationThrowable;
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e2) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"if (!idleQueue.offerFirst(this)) {
",0
"} catch (Exception e1) {
",0
"public class DefaultPooledObject<T> implements PooledObject<T> {
",0
"} catch (Exception e1) {
",0
"ObjectDeque<T> queue = poolMap.get(k);
",0
"} catch (Exception e) {
",0
"borrowedCount++;
",0
"if (!idleQueue.offerFirst(this)) {
",0
"ObjectDeque<T> queue = poolMap.get(key);
",0
"ObjectDeque<T> queue = poolMap.get(key);
",0
"} catch (Exception e) {
",0
"} catch (final Exception e) {
",0
"} catch (final Exception e) {
",0
"} catch (final Exception e) {
",0
"if (!underTest.endEvictionTest(idleObjects)) {
",0
private int numActive;,0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"} catch(Exception e) {
",0
"this((KeyedPoolableObjectFactory)null,DEFAULT_MAX_SLEEPING,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max) {
this((KeyedPoolableObjectFactory)null,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(int max, int init) {
this((KeyedPoolableObjectFactory)null,max,init);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory) {
this(factory,DEFAULT_MAX_SLEEPING);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max) {
this(factory,max,DEFAULT_INIT_SLEEPING_CAPACITY);
}
public StackKeyedObjectPool(KeyedPoolableObjectFactory factory, int max, int init) {
_factory = factory;
_maxSleeping = (max < 0 ? DEFAULT_MAX_SLEEPING : max);
_initSleepingCapacity = (init < 1 ? DEFAULT_INIT_SLEEPING_CAPACITY : init);
_pools = new HashMap();
_activeCount = new HashMap();
}
public synchronized Object borrowObject(Object key) throws Exception {
assertOpen();
Stack stack = (Stack)(_pools.get(key));
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
Object obj = null;
do {
boolean newlyMade = false;
if (!stack.empty()) {
obj = stack.pop();
_totIdle--;
} else {
if(null == _factory) {
throw new NoSuchElementException(""pools without a factory cannot create new objects as needed."");
} else {
obj = _factory.makeObject(key);
newlyMade = true;
}
}
if (null != _factory && null != obj) {
try {
_factory.activateObject(key, obj);
if (!_factory.validateObject(key, obj)) {
throw new Exception(""ValidateObject failed"");
}
} catch (Throwable t) {
try {
_factory.destroyObject(key,obj);
} catch (Throwable t2) {
} finally {
obj = null;
}
if (newlyMade) {
throw new NoSuchElementException(
""Could not create a validated object, cause: "" +
t.getMessage());
}
}
}
} while (obj == null);
incrementActiveCount(key);
return obj;
}
public synchronized void returnObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if (null != _factory) {
if (_factory.validateObject(key, obj)) {
try {
_factory.passivateObject(key, obj);
} catch (Exception ex) {
_factory.destroyObject(key, obj);
return;
}
} else {
return;
}
}
if (isClosed()) {
if (null != _factory) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e) {
}
}
return;
}
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
if(null != _factory) {
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
}
}
}
stack.push(obj);
_totIdle++;
}
public synchronized void invalidateObject(Object key, Object obj) throws Exception {
decrementActiveCount(key);
if(null != _factory) {
_factory.destroyObject(key,obj);
}
notifyAll(); 
}
public synchronized void addObject(Object key) throws Exception {
assertOpen();
if (_factory == null) {
throw new IllegalStateException(""Cannot add objects without a factory."");
}
Object obj = _factory.makeObject(key);
try {
if (!_factory.validateObject(key, obj)) {
return;
}
} catch (Exception e) {
try {
_factory.destroyObject(key, obj);
} catch (Exception e2) {
}
return;
}
_factory.passivateObject(key, obj);
Stack stack = (Stack)_pools.get(key);
if(null == stack) {
stack = new Stack();
stack.ensureCapacity( _initSleepingCapacity > _maxSleeping ? _maxSleeping : _initSleepingCapacity);
_pools.put(key,stack);
}
final int stackSize = stack.size();
if (stackSize >= _maxSleeping) {
final Object staleObj;
if (stackSize > 0) {
staleObj = stack.remove(0);
_totIdle--;
} else {
staleObj = obj;
}
try {
_factory.destroyObject(key, staleObj);
} catch (Exception e) {
if (obj == staleObj) {
throw e;
}
}
} else {
stack.push(obj);
_totIdle++;
}
}
public synchronized int getNumIdle() {
return _totIdle;
}
public int getNumActive() {
return _totActive;
}
public synchronized int getNumActive(Object key) {
return getActiveCount(key);
}
public synchronized int getNumIdle(Object key) {
try {
return((Stack)(_pools.get(key))).size();
} catch(Exception e) {
return 0;
}
}
public synchronized void clear() {
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
Stack stack = (Stack)(_pools.get(key));
destroyStack(key,stack);
}
_totIdle = 0;
_pools.clear();
_activeCount.clear();
}
public synchronized void clear(Object key) {
Stack stack = (Stack)(_pools.remove(key));
destroyStack(key,stack);
}
private synchronized void destroyStack(Object key, Stack stack) {
if(null == stack) {
return;
} else {
if(null != _factory) {
Iterator it = stack.iterator();
while(it.hasNext()) {
try {
_factory.destroyObject(key,it.next());
} catch(Exception e) {
}
}
}
_totIdle -= stack.size();
_activeCount.remove(key);
stack.clear();
}
}
public synchronized String toString() {
StringBuffer buf = new StringBuffer();
buf.append(getClass().getName());
buf.append("" contains "").append(_pools.size()).append("" distinct pools: "");
Iterator it = _pools.keySet().iterator();
while(it.hasNext()) {
Object key = it.next();
buf.append("" |"").append(key).append(""|="");
Stack s = (Stack)(_pools.get(key));
buf.append(s.size());
}
return buf.toString();
}
public void close() throws Exception {
super.close();
clear();
}
public synchronized void setFactory(KeyedPoolableObjectFactory factory) throws IllegalStateException {
if(0 < getNumActive()) {
throw new IllegalStateException(""Objects are already active"");
} else {
clear();
_factory = factory;
}
}
private int getActiveCount(Object key) {
try {
return ((Integer)_activeCount.get(key)).intValue();
} catch(NoSuchElementException e) {
return 0;
} catch(NullPointerException e) {
return 0;
}
}
private void incrementActiveCount(Object key) {
_totActive++;
Integer old = (Integer)(_activeCount.get(key));
if(null == old) {
_activeCount.put(key,new Integer(1));
} else {
_activeCount.put(key,new Integer(old.intValue() + 1));
}
}
private void decrementActiveCount(Object key) {
_totActive--;
Integer active = (Integer)(_activeCount.get(key));
if(null == active) {
} else if(active.intValue() <= 1) {
_activeCount.remove(key);
} else {
_activeCount.put(key, new Integer(active.intValue() - 1));
}
}
protected static final int DEFAULT_MAX_SLEEPING  = 8;
protected static final int DEFAULT_INIT_SLEEPING_CAPACITY = 4;
protected HashMap _pools = null;
protected KeyedPoolableObjectFactory _factory = null;
protected int _maxSleeping = DEFAULT_MAX_SLEEPING;
protected int _initSleepingCapacity = DEFAULT_INIT_SLEEPING_CAPACITY;
protected int _totActive = 0;
protected int _totIdle = 0;
protected HashMap _activeCount = null;
",0
"} catch (Exception e) {
",0
"} catch (Exception e) {
",0
"ObjectDeque<T> queue = poolMap.get(key);
",0
"ObjectDeque<T> queue = poolMap.get(key);
",0
"ObjectDeque<T> queue = poolMap.get(k);
",0
